<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-decoration: none;
            font-weight: bold;
            z-index: 100;
        }

        .game-area {
            text-align: center;
        }

        .title {
            font-size: 48px;
            color: #00d4ff;
            text-shadow: 0 0 20px #00d4ff;
            margin-bottom: 20px;
            font-weight: bold;
        }

        #gameCanvas {
            border: 3px solid #00d4ff;
            background: #000;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .side-panel {
            width: 200px;
            font-size: 18px;
        }

        .stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
            margin-bottom: 20px;
        }

        .stats h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            text-align: center;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }

        .next-piece {
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
            text-align: center;
        }

        .next-piece h3 {
            color: #00d4ff;
            margin-bottom: 15px;
        }

        #nextCanvas {
            border: 1px solid #555;
            background: #000;
        }

        .controls {
            margin-top: 20px;
            font-size: 14px;
            text-align: center;
        }

        .controls p {
            margin: 5px 0;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #00d4ff;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            color: #ff4757;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff4757;
        }

        .restart-btn {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 25px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            background: #00b8e6;
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                gap: 15px;
            }

            .side-panel {
                width: 100%;
                max-width: 300px;
            }

            .title {
                font-size: 32px;
            }

            #gameCanvas {
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <a href="../../game.html" class="back-link">← Back to Games</a>

    <div class="game-container">
        <div class="side-panel">
            <div class="stats">
                <h3>STATS</h3>
                <div class="stat-row">
                    <span>Score:</span>
                    <span id="score">0</span>
                </div>
                <div class="stat-row">
                    <span>Lines:</span>
                    <span id="lines">0</span>
                </div>
                <div class="stat-row">
                    <span>Level:</span>
                    <span id="level">1</span>
                </div>
                <div class="stat-row">
                    <span>High Score:</span>
                    <span id="highScore">0</span>
                </div>
            </div>

            <div class="next-piece">
                <h3>NEXT</h3>
                <canvas id="nextCanvas" width="80" height="80"></canvas>
            </div>
        </div>

        <div class="game-area">
            <h1 class="title">TETRIS</h1>
            <canvas id="gameCanvas" width="300" height="600"></canvas>

            <div class="controls">
                <p><strong>Controls:</strong></p>
                <p>← → Move | ↓ Soft Drop | ↑ Rotate</p>
                <p>Space - Hard Drop | P - Pause | R - Restart</p>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Lines Cleared: <span id="finalLines">0</span></p>
        <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script>
        class TetrisGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nextCanvas = document.getElementById('nextCanvas');
                this.nextCtx = this.nextCanvas.getContext('2d');

                this.gridWidth = 10;
                this.gridHeight = 20;
                this.blockSize = 30;

                this.grid = this.createGrid();
                this.currentPiece = null;
                this.nextPiece = null;
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.highScore = localStorage.getItem('tetris-high-score') || 0;

                this.dropTime = 0;
                this.dropInterval = 1000;
                this.lastTime = 0;
                this.gameRunning = false;
                this.paused = false;

                this.colors = [
                    '#000',     // 0: empty
                    '#ff6b6b', // 1: I
                    '#4ecdc4', // 2: O
                    '#45b7d1', // 3: T
                    '#f9ca24', // 4: S
                    '#f0932b', // 5: Z
                    '#eb4d4b', // 6: J
                    '#6c5ce7'  // 7: L
                ];

                this.pieces = {
                    I: { shape: [[1,1,1,1]], color: 1 },
                    O: { shape: [[2,2],[2,2]], color: 2 },
                    T: { shape: [[0,3,0],[3,3,3]], color: 3 },
                    S: { shape: [[0,4,4],[4,4,0]], color: 4 },
                    Z: { shape: [[5,5,0],[0,5,5]], color: 5 },
                    J: { shape: [[6,0,0],[6,6,6]], color: 6 },
                    L: { shape: [[0,0,7],[7,7,7]], color: 7 }
                };

                this.setupEventListeners();
                this.updateUI();
                this.newPiece();
                this.gameLoop();
            }

            createGrid() {
                return Array(this.gridHeight).fill().map(() => Array(this.gridWidth).fill(0));
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.paused) {
                        if (e.key.toLowerCase() === 'p') {
                            this.togglePause();
                        } else if (e.key.toLowerCase() === 'r') {
                            this.restart();
                        } else if (!this.gameRunning && !this.paused) {
                            this.startGame();
                        }
                        return;
                    }

                    switch (e.key) {
                        case 'ArrowLeft':
                            this.movePiece(-1, 0);
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.movePiece(1, 0);
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            this.movePiece(0, 1);
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                            this.rotatePiece();
                            e.preventDefault();
                            break;
                        case ' ':
                            this.hardDrop();
                            e.preventDefault();
                            break;
                        case 'p':
                        case 'P':
                            this.togglePause();
                            break;
                        case 'r':
                        case 'R':
                            this.restart();
                            break;
                    }
                });

                // Touch controls for mobile
                let touchStartY = 0;
                let touchStartX = 0;

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning && !this.paused) {
                        this.startGame();
                        return;
                    }

                    const rect = this.canvas.getBoundingClientRect();
                    touchStartX = e.touches[0].clientX - rect.left;
                    touchStartY = e.touches[0].clientY - rect.top;
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || this.paused) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const touchEndX = e.changedTouches[0].clientX - rect.left;
                    const touchEndY = e.changedTouches[0].clientY - rect.top;

                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;

                    const minSwipeDistance = 30;

                    if (Math.abs(deltaY) > Math.abs(deltaX)) {
                        if (deltaY > minSwipeDistance) {
                            this.hardDrop();
                        } else if (deltaY < -minSwipeDistance) {
                            this.rotatePiece();
                        }
                    } else {
                        if (Math.abs(deltaX) > minSwipeDistance) {
                            if (deltaX > 0) {
                                this.movePiece(1, 0);
                            } else {
                                this.movePiece(-1, 0);
                            }
                        }
                    }
                });
            }

            startGame() {
                this.gameRunning = true;
                this.paused = false;
            }

            togglePause() {
                if (this.gameRunning) {
                    this.paused = !this.paused;
                }
            }

            newPiece() {
                if (!this.nextPiece) {
                    const pieceTypes = Object.keys(this.pieces);
                    this.nextPiece = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
                }

                this.currentPiece = {
                    shape: this.pieces[this.nextPiece].shape,
                    color: this.pieces[this.nextPiece].color,
                    x: Math.floor(this.gridWidth / 2) - Math.floor(this.pieces[this.nextPiece].shape[0].length / 2),
                    y: 0
                };

                const pieceTypes = Object.keys(this.pieces);
                this.nextPiece = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];

                if (!this.isValidPosition(this.currentPiece)) {
                    this.gameOver();
                }
            }

            isValidPosition(piece) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x] !== 0) {
                            const newX = piece.x + x;
                            const newY = piece.y + y;

                            if (newX < 0 || newX >= this.gridWidth ||
                                newY >= this.gridHeight ||
                                (newY >= 0 && this.grid[newY][newX] !== 0)) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            movePiece(dx, dy) {
                const newPiece = {
                    ...this.currentPiece,
                    x: this.currentPiece.x + dx,
                    y: this.currentPiece.y + dy
                };

                if (this.isValidPosition(newPiece)) {
                    this.currentPiece = newPiece;
                    return true;
                }
                return false;
            }

            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, index) =>
                    this.currentPiece.shape.map(row => row[index]).reverse()
                );

                const rotatedPiece = {
                    ...this.currentPiece,
                    shape: rotated
                };

                if (this.isValidPosition(rotatedPiece)) {
                    this.currentPiece.shape = rotated;
                }
            }

            hardDrop() {
                while (this.movePiece(0, 1)) {
                    this.score += 2;
                }
                this.lockPiece();
            }

            lockPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x] !== 0) {
                            const gridY = this.currentPiece.y + y;
                            const gridX = this.currentPiece.x + x;
                            if (gridY >= 0) {
                                this.grid[gridY][gridX] = this.currentPiece.color;
                            }
                        }
                    }
                }

                this.clearLines();
                this.newPiece();
            }

            clearLines() {
                let linesCleared = 0;

                for (let y = this.gridHeight - 1; y >= 0; y--) {
                    if (this.grid[y].every(cell => cell !== 0)) {
                        this.grid.splice(y, 1);
                        this.grid.unshift(Array(this.gridWidth).fill(0));
                        linesCleared++;
                        y++;
                    }
                }

                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;

                    // Level up every 10 lines
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(50, 1000 - (this.level - 1) * 50);

                    this.updateUI();
                }
            }

            update(deltaTime) {
                if (!this.gameRunning || this.paused) return;

                this.dropTime += deltaTime;

                if (this.dropTime > this.dropInterval) {
                    if (!this.movePiece(0, 1)) {
                        this.lockPiece();
                    }
                    this.dropTime = 0;
                }
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= this.gridWidth; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.blockSize, 0);
                    this.ctx.lineTo(x * this.blockSize, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= this.gridHeight; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.blockSize);
                    this.ctx.lineTo(this.canvas.width, y * this.blockSize);
                    this.ctx.stroke();
                }

                // Draw placed blocks
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        if (this.grid[y][x] !== 0) {
                            this.drawBlock(x, y, this.colors[this.grid[y][x]]);
                        }
                    }
                }

                // Draw current piece
                if (this.currentPiece) {
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x] !== 0) {
                                this.drawBlock(
                                    this.currentPiece.x + x,
                                    this.currentPiece.y + y,
                                    this.colors[this.currentPiece.color]
                                );
                            }
                        }
                    }
                }

                // Draw pause overlay
                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                }

                // Draw start message
                if (!this.gameRunning && !this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Press any key to start', this.canvas.width / 2, this.canvas.height / 2);
                }

                // Draw next piece
                this.renderNextPiece();
            }

            renderNextPiece() {
                this.nextCtx.fillStyle = '#000';
                this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);

                if (this.nextPiece) {
                    const piece = this.pieces[this.nextPiece];
                    const blockSize = 15;
                    const offsetX = (this.nextCanvas.width - piece.shape[0].length * blockSize) / 2;
                    const offsetY = (this.nextCanvas.height - piece.shape.length * blockSize) / 2;

                    for (let y = 0; y < piece.shape.length; y++) {
                        for (let x = 0; x < piece.shape[y].length; x++) {
                            if (piece.shape[y][x] !== 0) {
                                this.nextCtx.fillStyle = this.colors[piece.color];
                                this.nextCtx.fillRect(
                                    offsetX + x * blockSize,
                                    offsetY + y * blockSize,
                                    blockSize - 1,
                                    blockSize - 1
                                );
                            }
                        }
                    }
                }
            }

            drawBlock(x, y, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(
                    x * this.blockSize + 1,
                    y * this.blockSize + 1,
                    this.blockSize - 2,
                    this.blockSize - 2
                );

                // Add highlight
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fillRect(
                    x * this.blockSize + 1,
                    y * this.blockSize + 1,
                    this.blockSize - 2,
                    3
                );
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lines').textContent = this.lines;
                document.getElementById('level').textContent = this.level;
                document.getElementById('highScore').textContent = this.highScore;
            }

            gameOver() {
                this.gameRunning = false;

                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('tetris-high-score', this.highScore);
                }

                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLines').textContent = this.lines;
                document.getElementById('gameOver').classList.add('show');
            }

            restart() {
                this.grid = this.createGrid();
                this.currentPiece = null;
                this.nextPiece = null;
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.dropTime = 0;
                this.dropInterval = 1000;
                this.gameRunning = false;
                this.paused = false;

                document.getElementById('gameOver').classList.remove('show');
                this.updateUI();
                this.newPiece();
            }

            gameLoop(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        let game;

        function startGame() {
            game = new TetrisGame();
            document.getElementById('highScore').textContent = game.highScore;
        }

        function restartGame() {
            game.restart();
        }

        window.addEventListener('load', startGame);
    </script>
</body>
</html>