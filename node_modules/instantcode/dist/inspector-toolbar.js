"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
      if (decorator = decorators[i6])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

  // node_modules/@lit/reactive-element/css-tag.js
  var t = globalThis;
  var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s = Symbol();
  var o = /* @__PURE__ */ new WeakMap();
  var n = class {
    constructor(t6, e8, o8) {
      if (this._$cssResult$ = true, o8 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t6, this.t = e8;
    }
    get styleSheet() {
      let t6 = this.o;
      const s5 = this.t;
      if (e && void 0 === t6) {
        const e8 = void 0 !== s5 && 1 === s5.length;
        e8 && (t6 = o.get(s5)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e8 && o.set(s5, t6));
      }
      return t6;
    }
    toString() {
      return this.cssText;
    }
  };
  var r = (t6) => new n("string" == typeof t6 ? t6 : t6 + "", void 0, s);
  var i = (t6, ...e8) => {
    const o8 = 1 === t6.length ? t6[0] : e8.reduce(((e9, s5, o9) => e9 + ((t7) => {
      if (true === t7._$cssResult$) return t7.cssText;
      if ("number" == typeof t7) return t7;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t7 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s5) + t6[o9 + 1]), t6[0]);
    return new n(o8, t6, s);
  };
  var S = (s5, o8) => {
    if (e) s5.adoptedStyleSheets = o8.map(((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet));
    else for (const e8 of o8) {
      const o9 = document.createElement("style"), n8 = t.litNonce;
      void 0 !== n8 && o9.setAttribute("nonce", n8), o9.textContent = e8.cssText, s5.appendChild(o9);
    }
  };
  var c = e ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
    let e8 = "";
    for (const s5 of t7.cssRules) e8 += s5.cssText;
    return r(e8);
  })(t6) : t6;

  // node_modules/@lit/reactive-element/reactive-element.js
  var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: h, getOwnPropertyNames: r2, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
  var a = globalThis;
  var c2 = a.trustedTypes;
  var l = c2 ? c2.emptyScript : "";
  var p = a.reactiveElementPolyfillSupport;
  var d = (t6, s5) => t6;
  var u = { toAttribute(t6, s5) {
    switch (s5) {
      case Boolean:
        t6 = t6 ? l : null;
        break;
      case Object:
      case Array:
        t6 = null == t6 ? t6 : JSON.stringify(t6);
    }
    return t6;
  }, fromAttribute(t6, s5) {
    let i6 = t6;
    switch (s5) {
      case Boolean:
        i6 = null !== t6;
        break;
      case Number:
        i6 = null === t6 ? null : Number(t6);
        break;
      case Object:
      case Array:
        try {
          i6 = JSON.parse(t6);
        } catch (t7) {
          i6 = null;
        }
    }
    return i6;
  } };
  var f = (t6, s5) => !i2(t6, s5);
  var b = { attribute: true, type: String, converter: u, reflect: false, useDefault: false, hasChanged: f };
  Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a.litPropertyMetadata ?? (a.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
  var y = class extends HTMLElement {
    static addInitializer(t6) {
      this._$Ei(), (this.l ?? (this.l = [])).push(t6);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t6, s5 = b) {
      if (s5.state && (s5.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t6) && ((s5 = Object.create(s5)).wrapped = true), this.elementProperties.set(t6, s5), !s5.noAccessor) {
        const i6 = Symbol(), h5 = this.getPropertyDescriptor(t6, i6, s5);
        void 0 !== h5 && e2(this.prototype, t6, h5);
      }
    }
    static getPropertyDescriptor(t6, s5, i6) {
      const { get: e8, set: r7 } = h(this.prototype, t6) ?? { get() {
        return this[s5];
      }, set(t7) {
        this[s5] = t7;
      } };
      return { get: e8, set(s6) {
        const h5 = e8?.call(this);
        r7?.call(this, s6), this.requestUpdate(t6, h5, i6);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t6) {
      return this.elementProperties.get(t6) ?? b;
    }
    static _$Ei() {
      if (this.hasOwnProperty(d("elementProperties"))) return;
      const t6 = n2(this);
      t6.finalize(), void 0 !== t6.l && (this.l = [...t6.l]), this.elementProperties = new Map(t6.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(d("finalized"))) return;
      if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
        const t7 = this.properties, s5 = [...r2(t7), ...o2(t7)];
        for (const i6 of s5) this.createProperty(i6, t7[i6]);
      }
      const t6 = this[Symbol.metadata];
      if (null !== t6) {
        const s5 = litPropertyMetadata.get(t6);
        if (void 0 !== s5) for (const [t7, i6] of s5) this.elementProperties.set(t7, i6);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [t7, s5] of this.elementProperties) {
        const i6 = this._$Eu(t7, s5);
        void 0 !== i6 && this._$Eh.set(i6, t7);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(s5) {
      const i6 = [];
      if (Array.isArray(s5)) {
        const e8 = new Set(s5.flat(1 / 0).reverse());
        for (const s6 of e8) i6.unshift(c(s6));
      } else void 0 !== s5 && i6.push(c(s5));
      return i6;
    }
    static _$Eu(t6, s5) {
      const i6 = s5.attribute;
      return false === i6 ? void 0 : "string" == typeof i6 ? i6 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      this._$ES = new Promise(((t6) => this.enableUpdating = t6)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t6) => t6(this)));
    }
    addController(t6) {
      (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t6), void 0 !== this.renderRoot && this.isConnected && t6.hostConnected?.();
    }
    removeController(t6) {
      this._$EO?.delete(t6);
    }
    _$E_() {
      const t6 = /* @__PURE__ */ new Map(), s5 = this.constructor.elementProperties;
      for (const i6 of s5.keys()) this.hasOwnProperty(i6) && (t6.set(i6, this[i6]), delete this[i6]);
      t6.size > 0 && (this._$Ep = t6);
    }
    createRenderRoot() {
      const t6 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return S(t6, this.constructor.elementStyles), t6;
    }
    connectedCallback() {
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$EO?.forEach(((t6) => t6.hostConnected?.()));
    }
    enableUpdating(t6) {
    }
    disconnectedCallback() {
      this._$EO?.forEach(((t6) => t6.hostDisconnected?.()));
    }
    attributeChangedCallback(t6, s5, i6) {
      this._$AK(t6, i6);
    }
    _$ET(t6, s5) {
      const i6 = this.constructor.elementProperties.get(t6), e8 = this.constructor._$Eu(t6, i6);
      if (void 0 !== e8 && true === i6.reflect) {
        const h5 = (void 0 !== i6.converter?.toAttribute ? i6.converter : u).toAttribute(s5, i6.type);
        this._$Em = t6, null == h5 ? this.removeAttribute(e8) : this.setAttribute(e8, h5), this._$Em = null;
      }
    }
    _$AK(t6, s5) {
      const i6 = this.constructor, e8 = i6._$Eh.get(t6);
      if (void 0 !== e8 && this._$Em !== e8) {
        const t7 = i6.getPropertyOptions(e8), h5 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== t7.converter?.fromAttribute ? t7.converter : u;
        this._$Em = e8;
        const r7 = h5.fromAttribute(s5, t7.type);
        this[e8] = r7 ?? this._$Ej?.get(e8) ?? r7, this._$Em = null;
      }
    }
    requestUpdate(t6, s5, i6) {
      if (void 0 !== t6) {
        const e8 = this.constructor, h5 = this[t6];
        if (i6 ?? (i6 = e8.getPropertyOptions(t6)), !((i6.hasChanged ?? f)(h5, s5) || i6.useDefault && i6.reflect && h5 === this._$Ej?.get(t6) && !this.hasAttribute(e8._$Eu(t6, i6)))) return;
        this.C(t6, s5, i6);
      }
      false === this.isUpdatePending && (this._$ES = this._$EP());
    }
    C(t6, s5, { useDefault: i6, reflect: e8, wrapped: h5 }, r7) {
      i6 && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t6) && (this._$Ej.set(t6, r7 ?? s5 ?? this[t6]), true !== h5 || void 0 !== r7) || (this._$AL.has(t6) || (this.hasUpdated || i6 || (s5 = void 0), this._$AL.set(t6, s5)), true === e8 && this._$Em !== t6 && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t6));
    }
    async _$EP() {
      this.isUpdatePending = true;
      try {
        await this._$ES;
      } catch (t7) {
        Promise.reject(t7);
      }
      const t6 = this.scheduleUpdate();
      return null != t6 && await t6, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
          for (const [t8, s6] of this._$Ep) this[t8] = s6;
          this._$Ep = void 0;
        }
        const t7 = this.constructor.elementProperties;
        if (t7.size > 0) for (const [s6, i6] of t7) {
          const { wrapped: t8 } = i6, e8 = this[s6];
          true !== t8 || this._$AL.has(s6) || void 0 === e8 || this.C(s6, void 0, i6, e8);
        }
      }
      let t6 = false;
      const s5 = this._$AL;
      try {
        t6 = this.shouldUpdate(s5), t6 ? (this.willUpdate(s5), this._$EO?.forEach(((t7) => t7.hostUpdate?.())), this.update(s5)) : this._$EM();
      } catch (s6) {
        throw t6 = false, this._$EM(), s6;
      }
      t6 && this._$AE(s5);
    }
    willUpdate(t6) {
    }
    _$AE(t6) {
      this._$EO?.forEach(((t7) => t7.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
    }
    _$EM() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t6) {
      return true;
    }
    update(t6) {
      this._$Eq && (this._$Eq = this._$Eq.forEach(((t7) => this._$ET(t7, this[t7])))), this._$EM();
    }
    updated(t6) {
    }
    firstUpdated(t6) {
    }
  };
  y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, y[d("elementProperties")] = /* @__PURE__ */ new Map(), y[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: y }), (a.reactiveElementVersions ?? (a.reactiveElementVersions = [])).push("2.1.1");

  // node_modules/lit-html/lit-html.js
  var t2 = globalThis;
  var i3 = t2.trustedTypes;
  var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
  var e3 = "$lit$";
  var h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var o3 = "?" + h2;
  var n3 = `<${o3}>`;
  var r3 = document;
  var l2 = () => r3.createComment("");
  var c3 = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
  var a2 = Array.isArray;
  var u2 = (t6) => a2(t6) || "function" == typeof t6?.[Symbol.iterator];
  var d2 = "[ 	\n\f\r]";
  var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v = /-->/g;
  var _ = />/g;
  var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var p2 = /'/g;
  var g = /"/g;
  var $ = /^(?:script|style|textarea|title)$/i;
  var y2 = (t6) => (i6, ...s5) => ({ _$litType$: t6, strings: i6, values: s5 });
  var x = y2(1);
  var b2 = y2(2);
  var w = y2(3);
  var T = Symbol.for("lit-noChange");
  var E = Symbol.for("lit-nothing");
  var A = /* @__PURE__ */ new WeakMap();
  var C = r3.createTreeWalker(r3, 129);
  function P(t6, i6) {
    if (!a2(t6) || !t6.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return void 0 !== s2 ? s2.createHTML(i6) : i6;
  }
  var V = (t6, i6) => {
    const s5 = t6.length - 1, o8 = [];
    let r7, l3 = 2 === i6 ? "<svg>" : 3 === i6 ? "<math>" : "", c5 = f2;
    for (let i7 = 0; i7 < s5; i7++) {
      const s6 = t6[i7];
      let a3, u3, d3 = -1, y3 = 0;
      for (; y3 < s6.length && (c5.lastIndex = y3, u3 = c5.exec(s6), null !== u3); ) y3 = c5.lastIndex, c5 === f2 ? "!--" === u3[1] ? c5 = v : void 0 !== u3[1] ? c5 = _ : void 0 !== u3[2] ? ($.test(u3[2]) && (r7 = RegExp("</" + u3[2], "g")), c5 = m) : void 0 !== u3[3] && (c5 = m) : c5 === m ? ">" === u3[0] ? (c5 = r7 ?? f2, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c5.lastIndex - u3[2].length, a3 = u3[1], c5 = void 0 === u3[3] ? m : '"' === u3[3] ? g : p2) : c5 === g || c5 === p2 ? c5 = m : c5 === v || c5 === _ ? c5 = f2 : (c5 = m, r7 = void 0);
      const x2 = c5 === m && t6[i7 + 1].startsWith("/>") ? " " : "";
      l3 += c5 === f2 ? s6 + n3 : d3 >= 0 ? (o8.push(a3), s6.slice(0, d3) + e3 + s6.slice(d3) + h2 + x2) : s6 + h2 + (-2 === d3 ? i7 : x2);
    }
    return [P(t6, l3 + (t6[s5] || "<?>") + (2 === i6 ? "</svg>" : 3 === i6 ? "</math>" : "")), o8];
  };
  var N = class _N {
    constructor({ strings: t6, _$litType$: s5 }, n8) {
      let r7;
      this.parts = [];
      let c5 = 0, a3 = 0;
      const u3 = t6.length - 1, d3 = this.parts, [f5, v2] = V(t6, s5);
      if (this.el = _N.createElement(f5, n8), C.currentNode = this.el.content, 2 === s5 || 3 === s5) {
        const t7 = this.el.content.firstChild;
        t7.replaceWith(...t7.childNodes);
      }
      for (; null !== (r7 = C.nextNode()) && d3.length < u3; ) {
        if (1 === r7.nodeType) {
          if (r7.hasAttributes()) for (const t7 of r7.getAttributeNames()) if (t7.endsWith(e3)) {
            const i6 = v2[a3++], s6 = r7.getAttribute(t7).split(h2), e8 = /([.?@])?(.*)/.exec(i6);
            d3.push({ type: 1, index: c5, name: e8[2], strings: s6, ctor: "." === e8[1] ? H : "?" === e8[1] ? I : "@" === e8[1] ? L : k }), r7.removeAttribute(t7);
          } else t7.startsWith(h2) && (d3.push({ type: 6, index: c5 }), r7.removeAttribute(t7));
          if ($.test(r7.tagName)) {
            const t7 = r7.textContent.split(h2), s6 = t7.length - 1;
            if (s6 > 0) {
              r7.textContent = i3 ? i3.emptyScript : "";
              for (let i6 = 0; i6 < s6; i6++) r7.append(t7[i6], l2()), C.nextNode(), d3.push({ type: 2, index: ++c5 });
              r7.append(t7[s6], l2());
            }
          }
        } else if (8 === r7.nodeType) if (r7.data === o3) d3.push({ type: 2, index: c5 });
        else {
          let t7 = -1;
          for (; -1 !== (t7 = r7.data.indexOf(h2, t7 + 1)); ) d3.push({ type: 7, index: c5 }), t7 += h2.length - 1;
        }
        c5++;
      }
    }
    static createElement(t6, i6) {
      const s5 = r3.createElement("template");
      return s5.innerHTML = t6, s5;
    }
  };
  function S2(t6, i6, s5 = t6, e8) {
    if (i6 === T) return i6;
    let h5 = void 0 !== e8 ? s5._$Co?.[e8] : s5._$Cl;
    const o8 = c3(i6) ? void 0 : i6._$litDirective$;
    return h5?.constructor !== o8 && (h5?._$AO?.(false), void 0 === o8 ? h5 = void 0 : (h5 = new o8(t6), h5._$AT(t6, s5, e8)), void 0 !== e8 ? (s5._$Co ?? (s5._$Co = []))[e8] = h5 : s5._$Cl = h5), void 0 !== h5 && (i6 = S2(t6, h5._$AS(t6, i6.values), h5, e8)), i6;
  }
  var M = class {
    constructor(t6, i6) {
      this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i6;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t6) {
      const { el: { content: i6 }, parts: s5 } = this._$AD, e8 = (t6?.creationScope ?? r3).importNode(i6, true);
      C.currentNode = e8;
      let h5 = C.nextNode(), o8 = 0, n8 = 0, l3 = s5[0];
      for (; void 0 !== l3; ) {
        if (o8 === l3.index) {
          let i7;
          2 === l3.type ? i7 = new R(h5, h5.nextSibling, this, t6) : 1 === l3.type ? i7 = new l3.ctor(h5, l3.name, l3.strings, this, t6) : 6 === l3.type && (i7 = new z(h5, this, t6)), this._$AV.push(i7), l3 = s5[++n8];
        }
        o8 !== l3?.index && (h5 = C.nextNode(), o8++);
      }
      return C.currentNode = r3, e8;
    }
    p(t6) {
      let i6 = 0;
      for (const s5 of this._$AV) void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t6, s5, i6), i6 += s5.strings.length - 2) : s5._$AI(t6[i6])), i6++;
    }
  };
  var R = class _R {
    get _$AU() {
      return this._$AM?._$AU ?? this._$Cv;
    }
    constructor(t6, i6, s5, e8) {
      this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t6, this._$AB = i6, this._$AM = s5, this.options = e8, this._$Cv = e8?.isConnected ?? true;
    }
    get parentNode() {
      let t6 = this._$AA.parentNode;
      const i6 = this._$AM;
      return void 0 !== i6 && 11 === t6?.nodeType && (t6 = i6.parentNode), t6;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t6, i6 = this) {
      t6 = S2(this, t6, i6), c3(t6) ? t6 === E || null == t6 || "" === t6 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t6 !== this._$AH && t6 !== T && this._(t6) : void 0 !== t6._$litType$ ? this.$(t6) : void 0 !== t6.nodeType ? this.T(t6) : u2(t6) ? this.k(t6) : this._(t6);
    }
    O(t6) {
      return this._$AA.parentNode.insertBefore(t6, this._$AB);
    }
    T(t6) {
      this._$AH !== t6 && (this._$AR(), this._$AH = this.O(t6));
    }
    _(t6) {
      this._$AH !== E && c3(this._$AH) ? this._$AA.nextSibling.data = t6 : this.T(r3.createTextNode(t6)), this._$AH = t6;
    }
    $(t6) {
      const { values: i6, _$litType$: s5 } = t6, e8 = "number" == typeof s5 ? this._$AC(t6) : (void 0 === s5.el && (s5.el = N.createElement(P(s5.h, s5.h[0]), this.options)), s5);
      if (this._$AH?._$AD === e8) this._$AH.p(i6);
      else {
        const t7 = new M(e8, this), s6 = t7.u(this.options);
        t7.p(i6), this.T(s6), this._$AH = t7;
      }
    }
    _$AC(t6) {
      let i6 = A.get(t6.strings);
      return void 0 === i6 && A.set(t6.strings, i6 = new N(t6)), i6;
    }
    k(t6) {
      a2(this._$AH) || (this._$AH = [], this._$AR());
      const i6 = this._$AH;
      let s5, e8 = 0;
      for (const h5 of t6) e8 === i6.length ? i6.push(s5 = new _R(this.O(l2()), this.O(l2()), this, this.options)) : s5 = i6[e8], s5._$AI(h5), e8++;
      e8 < i6.length && (this._$AR(s5 && s5._$AB.nextSibling, e8), i6.length = e8);
    }
    _$AR(t6 = this._$AA.nextSibling, i6) {
      for (this._$AP?.(false, true, i6); t6 !== this._$AB; ) {
        const i7 = t6.nextSibling;
        t6.remove(), t6 = i7;
      }
    }
    setConnected(t6) {
      void 0 === this._$AM && (this._$Cv = t6, this._$AP?.(t6));
    }
  };
  var k = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t6, i6, s5, e8, h5) {
      this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t6, this.name = i6, this._$AM = e8, this.options = h5, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = E;
    }
    _$AI(t6, i6 = this, s5, e8) {
      const h5 = this.strings;
      let o8 = false;
      if (void 0 === h5) t6 = S2(this, t6, i6, 0), o8 = !c3(t6) || t6 !== this._$AH && t6 !== T, o8 && (this._$AH = t6);
      else {
        const e9 = t6;
        let n8, r7;
        for (t6 = h5[0], n8 = 0; n8 < h5.length - 1; n8++) r7 = S2(this, e9[s5 + n8], i6, n8), r7 === T && (r7 = this._$AH[n8]), o8 || (o8 = !c3(r7) || r7 !== this._$AH[n8]), r7 === E ? t6 = E : t6 !== E && (t6 += (r7 ?? "") + h5[n8 + 1]), this._$AH[n8] = r7;
      }
      o8 && !e8 && this.j(t6);
    }
    j(t6) {
      t6 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t6 ?? "");
    }
  };
  var H = class extends k {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t6) {
      this.element[this.name] = t6 === E ? void 0 : t6;
    }
  };
  var I = class extends k {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t6) {
      this.element.toggleAttribute(this.name, !!t6 && t6 !== E);
    }
  };
  var L = class extends k {
    constructor(t6, i6, s5, e8, h5) {
      super(t6, i6, s5, e8, h5), this.type = 5;
    }
    _$AI(t6, i6 = this) {
      if ((t6 = S2(this, t6, i6, 0) ?? E) === T) return;
      const s5 = this._$AH, e8 = t6 === E && s5 !== E || t6.capture !== s5.capture || t6.once !== s5.once || t6.passive !== s5.passive, h5 = t6 !== E && (s5 === E || e8);
      e8 && this.element.removeEventListener(this.name, this, s5), h5 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
    }
    handleEvent(t6) {
      "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t6) : this._$AH.handleEvent(t6);
    }
  };
  var z = class {
    constructor(t6, i6, s5) {
      this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s5;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t6) {
      S2(this, t6);
    }
  };
  var Z = { M: e3, P: h2, A: o3, C: 1, L: V, R: M, D: u2, V: S2, I: R, H: k, N: I, U: L, B: H, F: z };
  var j = t2.litHtmlPolyfillSupport;
  j?.(N, R), (t2.litHtmlVersions ?? (t2.litHtmlVersions = [])).push("3.3.1");
  var B = (t6, i6, s5) => {
    const e8 = s5?.renderBefore ?? i6;
    let h5 = e8._$litPart$;
    if (void 0 === h5) {
      const t7 = s5?.renderBefore ?? null;
      e8._$litPart$ = h5 = new R(i6.insertBefore(l2(), t7), t7, void 0, s5 ?? {});
    }
    return h5._$AI(t6), h5;
  };

  // node_modules/lit-element/lit-element.js
  var s3 = globalThis;
  var i4 = class extends y {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var _a;
      const t6 = super.createRenderRoot();
      return (_a = this.renderOptions).renderBefore ?? (_a.renderBefore = t6.firstChild), t6;
    }
    update(t6) {
      const r7 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this._$Do = B(r7, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      super.connectedCallback(), this._$Do?.setConnected(true);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._$Do?.setConnected(false);
    }
    render() {
      return T;
    }
  };
  i4._$litElement$ = true, i4["finalized"] = true, s3.litElementHydrateSupport?.({ LitElement: i4 });
  var o4 = s3.litElementPolyfillSupport;
  o4?.({ LitElement: i4 });
  (s3.litElementVersions ?? (s3.litElementVersions = [])).push("4.2.1");

  // node_modules/@lit/reactive-element/decorators/custom-element.js
  var t3 = (t6) => (e8, o8) => {
    void 0 !== o8 ? o8.addInitializer((() => {
      customElements.define(t6, e8);
    })) : customElements.define(t6, e8);
  };

  // node_modules/@lit/reactive-element/decorators/property.js
  var o5 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
  var r4 = (t6 = o5, e8, r7) => {
    const { kind: n8, metadata: i6 } = r7;
    let s5 = globalThis.litPropertyMetadata.get(i6);
    if (void 0 === s5 && globalThis.litPropertyMetadata.set(i6, s5 = /* @__PURE__ */ new Map()), "setter" === n8 && ((t6 = Object.create(t6)).wrapped = true), s5.set(r7.name, t6), "accessor" === n8) {
      const { name: o8 } = r7;
      return { set(r8) {
        const n9 = e8.get.call(this);
        e8.set.call(this, r8), this.requestUpdate(o8, n9, t6);
      }, init(e9) {
        return void 0 !== e9 && this.C(o8, void 0, t6, e9), e9;
      } };
    }
    if ("setter" === n8) {
      const { name: o8 } = r7;
      return function(r8) {
        const n9 = this[o8];
        e8.call(this, r8), this.requestUpdate(o8, n9, t6);
      };
    }
    throw Error("Unsupported decorator location: " + n8);
  };
  function n4(t6) {
    return (e8, o8) => "object" == typeof o8 ? r4(t6, e8, o8) : ((t7, e9, o9) => {
      const r7 = e9.hasOwnProperty(o9);
      return e9.constructor.createProperty(o9, t7), r7 ? Object.getOwnPropertyDescriptor(e9, o9) : void 0;
    })(t6, e8, o8);
  }

  // node_modules/@lit/reactive-element/decorators/state.js
  function r5(r7) {
    return n4({ ...r7, state: true, attribute: false });
  }

  // node_modules/lit-html/directives/when.js
  function n5(n8, r7, t6) {
    return n8 ? r7(n8) : t6?.(n8);
  }

  // node_modules/lit-html/directive.js
  var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
  var e5 = (t6) => (...e8) => ({ _$litDirective$: t6, values: e8 });
  var i5 = class {
    constructor(t6) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t6, e8, i6) {
      this._$Ct = t6, this._$AM = e8, this._$Ci = i6;
    }
    _$AS(t6, e8) {
      return this.update(t6, e8);
    }
    update(t6, e8) {
      return this.render(...e8);
    }
  };

  // node_modules/lit-html/directives/class-map.js
  var e6 = e5(class extends i5 {
    constructor(t6) {
      if (super(t6), t6.type !== t4.ATTRIBUTE || "class" !== t6.name || t6.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
    render(t6) {
      return " " + Object.keys(t6).filter(((s5) => t6[s5])).join(" ") + " ";
    }
    update(s5, [i6]) {
      if (void 0 === this.st) {
        this.st = /* @__PURE__ */ new Set(), void 0 !== s5.strings && (this.nt = new Set(s5.strings.join(" ").split(/\s/).filter(((t6) => "" !== t6))));
        for (const t6 in i6) i6[t6] && !this.nt?.has(t6) && this.st.add(t6);
        return this.render(i6);
      }
      const r7 = s5.element.classList;
      for (const t6 of this.st) t6 in i6 || (r7.remove(t6), this.st.delete(t6));
      for (const t6 in i6) {
        const s6 = !!i6[t6];
        s6 === this.st.has(t6) || this.nt?.has(t6) || (s6 ? (r7.add(t6), this.st.add(t6)) : (r7.remove(t6), this.st.delete(t6)));
      }
      return T;
    }
  });

  // node_modules/lit-html/directive-helpers.js
  var { I: t5 } = Z;
  var f3 = (o8) => void 0 === o8.strings;

  // node_modules/lit-html/async-directive.js
  var s4 = (i6, t6) => {
    const e8 = i6._$AN;
    if (void 0 === e8) return false;
    for (const i7 of e8) i7._$AO?.(t6, false), s4(i7, t6);
    return true;
  };
  var o6 = (i6) => {
    let t6, e8;
    do {
      if (void 0 === (t6 = i6._$AM)) break;
      e8 = t6._$AN, e8.delete(i6), i6 = t6;
    } while (0 === e8?.size);
  };
  var r6 = (i6) => {
    for (let t6; t6 = i6._$AM; i6 = t6) {
      let e8 = t6._$AN;
      if (void 0 === e8) t6._$AN = e8 = /* @__PURE__ */ new Set();
      else if (e8.has(i6)) break;
      e8.add(i6), c4(t6);
    }
  };
  function h3(i6) {
    void 0 !== this._$AN ? (o6(this), this._$AM = i6, r6(this)) : this._$AM = i6;
  }
  function n6(i6, t6 = false, e8 = 0) {
    const r7 = this._$AH, h5 = this._$AN;
    if (void 0 !== h5 && 0 !== h5.size) if (t6) if (Array.isArray(r7)) for (let i7 = e8; i7 < r7.length; i7++) s4(r7[i7], false), o6(r7[i7]);
    else null != r7 && (s4(r7, false), o6(r7));
    else s4(this, i6);
  }
  var c4 = (i6) => {
    i6.type == t4.CHILD && (i6._$AP ?? (i6._$AP = n6), i6._$AQ ?? (i6._$AQ = h3));
  };
  var f4 = class extends i5 {
    constructor() {
      super(...arguments), this._$AN = void 0;
    }
    _$AT(i6, t6, e8) {
      super._$AT(i6, t6, e8), r6(this), this.isConnected = i6._$AU;
    }
    _$AO(i6, t6 = true) {
      i6 !== this.isConnected && (this.isConnected = i6, i6 ? this.reconnected?.() : this.disconnected?.()), t6 && (s4(this, i6), o6(this));
    }
    setValue(t6) {
      if (f3(this._$Ct)) this._$Ct._$AI(t6, this);
      else {
        const i6 = [...this._$Ct._$AH];
        i6[this._$Ci] = t6, this._$Ct._$AI(i6, this, 0);
      }
    }
    disconnected() {
    }
    reconnected() {
    }
  };

  // node_modules/lit-html/directives/ref.js
  var e7 = () => new h4();
  var h4 = class {
  };
  var o7 = /* @__PURE__ */ new WeakMap();
  var n7 = e5(class extends f4 {
    render(i6) {
      return E;
    }
    update(i6, [s5]) {
      const e8 = s5 !== this.G;
      return e8 && void 0 !== this.G && this.rt(void 0), (e8 || this.lt !== this.ct) && (this.G = s5, this.ht = i6.options?.host, this.rt(this.ct = i6.element)), E;
    }
    rt(t6) {
      if (this.isConnected || (t6 = void 0), "function" == typeof this.G) {
        const i6 = this.ht ?? globalThis;
        let s5 = o7.get(i6);
        void 0 === s5 && (s5 = /* @__PURE__ */ new WeakMap(), o7.set(i6, s5)), void 0 !== s5.get(this.G) && this.G.call(this.ht, void 0), s5.set(this.G, t6), void 0 !== t6 && this.G.call(this.ht, t6);
      } else this.G.value = t6;
    }
    get lt() {
      return "function" == typeof this.G ? o7.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
    }
    disconnected() {
      this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
      this.rt(this.ct);
    }
  });

  // node_modules/js-yaml/dist/js-yaml.mjs
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  var exception = YAMLException$1;
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max) {
    return common.repeat(" ", max - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i6, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i6 = 1; i6 <= options.linesBefore; i6++) {
      if (foundLineNo - i6 < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i6],
        lineEnds[foundLineNo - i6],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i6]),
        maxLineLength
      );
      result = common.repeat(" ", options.indent) + padStart((mark.line - i6 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i6 = 1; i6 <= options.linesAfter; i6++) {
      if (foundLineNo + i6 >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i6],
        lineEnds[foundLineNo + i6],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i6]),
        maxLineLength
      );
      result += common.repeat(" ", options.indent) + padStart((mark.line + i6 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map3) {
    var result = {};
    if (map3 !== null) {
      Object.keys(map3).forEach(function(style) {
        map3[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$1;
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema$1(definition) {
    return this.extend(definition);
  }
  Schema$1.prototype.extend = function extend2(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$1.loadKind && type$1.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$1.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1;
  var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c5) {
    return 48 <= c5 && c5 <= 57 || 65 <= c5 && c5 <= 70 || 97 <= c5 && c5 <= 102;
  }
  function isOctCode(c5) {
    return 48 <= c5 && c5 <= 55;
  }
  function isDecCode(c5) {
    return 48 <= c5 && c5 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max) return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map3.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map3.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map3 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map3[bits >> 18 & 63];
        result += map3[bits >> 12 & 63];
        result += map3[bits >> 6 & 63];
        result += map3[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    } else if (tail === 2) {
      result += map3[bits >> 10 & 63];
      result += map3[bits >> 4 & 63];
      result += map3[bits << 2 & 63];
      result += map3[64];
    } else if (tail === 1) {
      result += map3[bits >> 2 & 63];
      result += map3[bits << 4 & 63];
      result += map3[64];
      result += map3[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c5) {
    return c5 === 10 || c5 === 13;
  }
  function is_WHITE_SPACE(c5) {
    return c5 === 9 || c5 === 32;
  }
  function is_WS_OR_EOL(c5) {
    return c5 === 9 || c5 === 32 || c5 === 10 || c5 === 13;
  }
  function is_FLOW_INDICATOR(c5) {
    return c5 === 44 || c5 === 91 || c5 === 93 || c5 === 123 || c5 === 125;
  }
  function fromHexCode(c5) {
    var lc;
    if (48 <= c5 && c5 <= 57) {
      return c5 - 48;
    }
    lc = c5 | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c5) {
    if (c5 === 120) {
      return 2;
    }
    if (c5 === 117) {
      return 4;
    }
    if (c5 === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c5) {
    if (48 <= c5 && c5 <= 57) {
      return c5 - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c5) {
    return c5 === 48 ? "\0" : c5 === 97 ? "\x07" : c5 === 98 ? "\b" : c5 === 116 ? "	" : c5 === 9 ? "	" : c5 === 110 ? "\n" : c5 === 118 ? "\v" : c5 === 102 ? "\f" : c5 === 114 ? "\r" : c5 === 101 ? "\x1B" : c5 === 32 ? " " : c5 === 34 ? '"' : c5 === 47 ? "/" : c5 === 92 ? "\\" : c5 === 78 ? "\x85" : c5 === 95 ? "\xA0" : c5 === 76 ? "\u2028" : c5 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c5) {
    if (c5 <= 65535) {
      return String.fromCharCode(c5);
    }
    return String.fromCharCode(
      (c5 - 65536 >> 10) + 55296,
      (c5 - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i6 = 0; i6 < 256; i6++) {
    simpleEscapeCheck[i6] = simpleEscapeSequence(i6) ? 1 : 0;
    simpleEscapeMap[i6] = simpleEscapeSequence(i6);
  }
  var i6;
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map3) {
    var result, keys, index, length, tag, style, type2;
    if (map3 === null) return {};
    result = {};
    keys = Object.keys(map3);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map3[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c5) {
    return c5 === CHAR_SPACE || c5 === CHAR_TAB;
  }
  function isPrintable(c5) {
    return 32 <= c5 && c5 <= 126 || 161 <= c5 && c5 <= 55295 && c5 !== 8232 && c5 !== 8233 || 57344 <= c5 && c5 <= 65533 && c5 !== CHAR_BOM || 65536 <= c5 && c5 <= 1114111;
  }
  function isNsCharOrWhitespace(c5) {
    return isPrintable(c5) && c5 !== CHAR_BOM && c5 !== CHAR_CARRIAGE_RETURN && c5 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c5, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c5);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c5);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c5 !== CHAR_COMMA && c5 !== CHAR_LEFT_SQUARE_BRACKET && c5 !== CHAR_RIGHT_SQUARE_BRACKET && c5 !== CHAR_LEFT_CURLY_BRACKET && c5 !== CHAR_RIGHT_CURLY_BRACKET) && c5 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c5 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c5) {
    return isPrintable(c5) && c5 !== CHAR_BOM && !isWhitespace(c5) && c5 !== CHAR_MINUS && c5 !== CHAR_QUESTION && c5 !== CHAR_COLON && c5 !== CHAR_COMMA && c5 !== CHAR_LEFT_SQUARE_BRACKET && c5 !== CHAR_RIGHT_SQUARE_BRACKET && c5 !== CHAR_LEFT_CURLY_BRACKET && c5 !== CHAR_RIGHT_CURLY_BRACKET && c5 !== CHAR_SHARP && c5 !== CHAR_AMPERSAND && c5 !== CHAR_ASTERISK && c5 !== CHAR_EXCLAMATION && c5 !== CHAR_VERTICAL_LINE && c5 !== CHAR_EQUALS && c5 !== CHAR_GREATER_THAN && c5 !== CHAR_SINGLE_QUOTE && c5 !== CHAR_DOUBLE_QUOTE && c5 !== CHAR_PERCENT && c5 !== CHAR_COMMERCIAL_AT && c5 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c5) {
    return !isWhitespace(c5) && c5 !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i6;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i6 = 0; i6 < string.length; char >= 65536 ? i6 += 2 : i6++) {
        char = codePointAt(string, i6);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i6 = 0; i6 < string.length; char >= 65536 ? i6 += 2 : i6++) {
        char = codePointAt(string, i6);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i6 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i6;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i6 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    })();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = (function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    })();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i6 = 0; i6 < string.length; char >= 65536 ? i6 += 2 : i6++) {
      char = codePointAt(string, i6);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i6];
        if (char >= 65536) result += string[i6 + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");

  // node_modules/html-to-image/es/util.js
  function resolveUrl(url, baseUrl) {
    if (url.match(/^[a-z]+:\/\//i)) {
      return url;
    }
    if (url.match(/^\/\//)) {
      return window.location.protocol + url;
    }
    if (url.match(/^[a-z]+:/i)) {
      return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base = doc.createElement("base");
    const a3 = doc.createElement("a");
    doc.head.appendChild(base);
    doc.body.appendChild(a3);
    if (baseUrl) {
      base.href = baseUrl;
    }
    a3.href = url;
    return a3.href;
  }
  var uuid = /* @__PURE__ */ (() => {
    let counter = 0;
    const random = () => (
      // eslint-disable-next-line no-bitwise
      `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
    );
    return () => {
      counter += 1;
      return `u${random()}${counter}`;
    };
  })();
  function toArray2(arrayLike) {
    const arr = [];
    for (let i6 = 0, l3 = arrayLike.length; i6 < l3; i6++) {
      arr.push(arrayLike[i6]);
    }
    return arr;
  }
  var styleProps = null;
  function getStyleProperties(options = {}) {
    if (styleProps) {
      return styleProps;
    }
    if (options.includeStyleProperties) {
      styleProps = options.includeStyleProperties;
      return styleProps;
    }
    styleProps = toArray2(window.getComputedStyle(document.documentElement));
    return styleProps;
  }
  function px(node, styleProperty) {
    const win = node.ownerDocument.defaultView || window;
    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
    return val ? parseFloat(val.replace("px", "")) : 0;
  }
  function getNodeWidth(node) {
    const leftBorder = px(node, "border-left-width");
    const rightBorder = px(node, "border-right-width");
    return node.clientWidth + leftBorder + rightBorder;
  }
  function getNodeHeight(node) {
    const topBorder = px(node, "border-top-width");
    const bottomBorder = px(node, "border-bottom-width");
    return node.clientHeight + topBorder + bottomBorder;
  }
  function getImageSize(targetNode, options = {}) {
    const width = options.width || getNodeWidth(targetNode);
    const height = options.height || getNodeHeight(targetNode);
    return { width, height };
  }
  function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
      FINAL_PROCESS = process;
    } catch (e8) {
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
    if (val) {
      ratio = parseInt(val, 10);
      if (Number.isNaN(ratio)) {
        ratio = 1;
      }
    }
    return ratio || window.devicePixelRatio || 1;
  }
  var canvasDimensionLimit = 16384;
  function checkCanvasDimensions(canvas) {
    if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvas.height) {
          canvas.height *= canvasDimensionLimit / canvas.width;
          canvas.width = canvasDimensionLimit;
        } else {
          canvas.width *= canvasDimensionLimit / canvas.height;
          canvas.height = canvasDimensionLimit;
        }
      } else if (canvas.width > canvasDimensionLimit) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    }
  }
  function createImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        img.decode().then(() => {
          requestAnimationFrame(() => resolve(img));
        });
      };
      img.onerror = reject;
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = url;
    });
  }
  async function svgToDataURL(svg) {
    return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
  }
  async function nodeToDataURL(node, width, height) {
    const xmlns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(xmlns, "svg");
    const foreignObject = document.createElementNS(xmlns, "foreignObject");
    svg.setAttribute("width", `${width}`);
    svg.setAttribute("height", `${height}`);
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    foreignObject.setAttribute("width", "100%");
    foreignObject.setAttribute("height", "100%");
    foreignObject.setAttribute("x", "0");
    foreignObject.setAttribute("y", "0");
    foreignObject.setAttribute("externalResourcesRequired", "true");
    svg.appendChild(foreignObject);
    foreignObject.appendChild(node);
    return svgToDataURL(svg);
  }
  var isInstanceOfElement = (node, instance) => {
    if (node instanceof instance)
      return true;
    const nodePrototype = Object.getPrototypeOf(node);
    if (nodePrototype === null)
      return false;
    return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
  };

  // node_modules/html-to-image/es/clone-pseudos.js
  function formatCSSText(style) {
    const content = style.getPropertyValue("content");
    return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
  }
  function formatCSSProperties(style, options) {
    return getStyleProperties(options).map((name) => {
      const value = style.getPropertyValue(name);
      const priority = style.getPropertyPriority(name);
      return `${name}: ${value}${priority ? " !important" : ""};`;
    }).join(" ");
  }
  function getPseudoElementStyle(className, pseudo, style, options) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style, options);
    return document.createTextNode(`${selector}{${cssText}}`);
  }
  function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
    const style = window.getComputedStyle(nativeNode, pseudo);
    const content = style.getPropertyValue("content");
    if (content === "" || content === "none") {
      return;
    }
    const className = uuid();
    try {
      clonedNode.className = `${clonedNode.className} ${className}`;
    } catch (err) {
      return;
    }
    const styleElement = document.createElement("style");
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));
    clonedNode.appendChild(styleElement);
  }
  function clonePseudoElements(nativeNode, clonedNode, options) {
    clonePseudoElement(nativeNode, clonedNode, ":before", options);
    clonePseudoElement(nativeNode, clonedNode, ":after", options);
  }

  // node_modules/html-to-image/es/mimes.js
  var WOFF = "application/font-woff";
  var JPEG = "image/jpeg";
  var mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: "application/font-truetype",
    eot: "application/vnd.ms-fontobject",
    png: "image/png",
    jpg: JPEG,
    jpeg: JPEG,
    gif: "image/gif",
    tiff: "image/tiff",
    svg: "image/svg+xml",
    webp: "image/webp"
  };
  function getExtension(url) {
    const match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : "";
  }
  function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || "";
  }

  // node_modules/html-to-image/es/dataurl.js
  function getContentFromDataUrl(dataURL) {
    return dataURL.split(/,/)[1];
  }
  function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
  }
  function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
  }
  async function fetchAsDataURL(url, init, process2) {
    const res = await fetch(url, init);
    if (res.status === 404) {
      throw new Error(`Resource "${res.url}" not found`);
    }
    const blob = await res.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onloadend = () => {
        try {
          resolve(process2({ res, result: reader.result }));
        } catch (error) {
          reject(error);
        }
      };
      reader.readAsDataURL(blob);
    });
  }
  var cache = {};
  function getCacheKey(url, contentType, includeQueryParams) {
    let key = url.replace(/\?.*/, "");
    if (includeQueryParams) {
      key = url;
    }
    if (/ttf|otf|eot|woff2?/i.test(key)) {
      key = key.replace(/.*\//, "");
    }
    return contentType ? `[${contentType}]${key}` : key;
  }
  async function resourceToDataURL(resourceUrl, contentType, options) {
    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
    if (cache[cacheKey] != null) {
      return cache[cacheKey];
    }
    if (options.cacheBust) {
      resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
    }
    let dataURL;
    try {
      const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {
        if (!contentType) {
          contentType = res.headers.get("Content-Type") || "";
        }
        return getContentFromDataUrl(result);
      });
      dataURL = makeDataUrl(content, contentType);
    } catch (error) {
      dataURL = options.imagePlaceholder || "";
      let msg = `Failed to fetch resource: ${resourceUrl}`;
      if (error) {
        msg = typeof error === "string" ? error : error.message;
      }
      if (msg) {
        console.warn(msg);
      }
    }
    cache[cacheKey] = dataURL;
    return dataURL;
  }

  // node_modules/html-to-image/es/clone-node.js
  async function cloneCanvasElement(canvas) {
    const dataURL = canvas.toDataURL();
    if (dataURL === "data:,") {
      return canvas.cloneNode(false);
    }
    return createImage(dataURL);
  }
  async function cloneVideoElement(video, options) {
    if (video.currentSrc) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = video.clientWidth;
      canvas.height = video.clientHeight;
      ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const dataURL2 = canvas.toDataURL();
      return createImage(dataURL2);
    }
    const poster = video.poster;
    const contentType = getMimeType(poster);
    const dataURL = await resourceToDataURL(poster, contentType, options);
    return createImage(dataURL);
  }
  async function cloneIFrameElement(iframe, options) {
    var _a;
    try {
      if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
        return await cloneNode(iframe.contentDocument.body, options, true);
      }
    } catch (_b) {
    }
    return iframe.cloneNode(false);
  }
  async function cloneSingleNode(node, options) {
    if (isInstanceOfElement(node, HTMLCanvasElement)) {
      return cloneCanvasElement(node);
    }
    if (isInstanceOfElement(node, HTMLVideoElement)) {
      return cloneVideoElement(node, options);
    }
    if (isInstanceOfElement(node, HTMLIFrameElement)) {
      return cloneIFrameElement(node, options);
    }
    return node.cloneNode(isSVGElement(node));
  }
  var isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
  var isSVGElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SVG";
  async function cloneChildren(nativeNode, clonedNode, options) {
    var _a, _b;
    if (isSVGElement(clonedNode)) {
      return clonedNode;
    }
    let children = [];
    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
      children = toArray2(nativeNode.assignedNodes());
    } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
      children = toArray2(nativeNode.contentDocument.body.childNodes);
    } else {
      children = toArray2(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
    }
    if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
      return clonedNode;
    }
    await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
      if (clonedChild) {
        clonedNode.appendChild(clonedChild);
      }
    }), Promise.resolve());
    return clonedNode;
  }
  function cloneCSSStyle(nativeNode, clonedNode, options) {
    const targetStyle = clonedNode.style;
    if (!targetStyle) {
      return;
    }
    const sourceStyle = window.getComputedStyle(nativeNode);
    if (sourceStyle.cssText) {
      targetStyle.cssText = sourceStyle.cssText;
      targetStyle.transformOrigin = sourceStyle.transformOrigin;
    } else {
      getStyleProperties(options).forEach((name) => {
        let value = sourceStyle.getPropertyValue(name);
        if (name === "font-size" && value.endsWith("px")) {
          const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
          value = `${reducedFont}px`;
        }
        if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
          value = "block";
        }
        if (name === "d" && clonedNode.getAttribute("d")) {
          value = `path(${clonedNode.getAttribute("d")})`;
        }
        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
      });
    }
  }
  function cloneInputValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
      clonedNode.innerHTML = nativeNode.value;
    }
    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
      clonedNode.setAttribute("value", nativeNode.value);
    }
  }
  function cloneSelectValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
      const clonedSelect = clonedNode;
      const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
      if (selectedOption) {
        selectedOption.setAttribute("selected", "");
      }
    }
  }
  function decorate(nativeNode, clonedNode, options) {
    if (isInstanceOfElement(clonedNode, Element)) {
      cloneCSSStyle(nativeNode, clonedNode, options);
      clonePseudoElements(nativeNode, clonedNode, options);
      cloneInputValue(nativeNode, clonedNode);
      cloneSelectValue(nativeNode, clonedNode);
    }
    return clonedNode;
  }
  async function ensureSVGSymbols(clone, options) {
    const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
    if (uses.length === 0) {
      return clone;
    }
    const processedDefs = {};
    for (let i6 = 0; i6 < uses.length; i6++) {
      const use = uses[i6];
      const id = use.getAttribute("xlink:href");
      if (id) {
        const exist = clone.querySelector(id);
        const definition = document.querySelector(id);
        if (!exist && definition && !processedDefs[id]) {
          processedDefs[id] = await cloneNode(definition, options, true);
        }
      }
    }
    const nodes = Object.values(processedDefs);
    if (nodes.length) {
      const ns = "http://www.w3.org/1999/xhtml";
      const svg = document.createElementNS(ns, "svg");
      svg.setAttribute("xmlns", ns);
      svg.style.position = "absolute";
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.overflow = "hidden";
      svg.style.display = "none";
      const defs = document.createElementNS(ns, "defs");
      svg.appendChild(defs);
      for (let i6 = 0; i6 < nodes.length; i6++) {
        defs.appendChild(nodes[i6]);
      }
      clone.appendChild(svg);
    }
    return clone;
  }
  async function cloneNode(node, options, isRoot) {
    if (!isRoot && options.filter && !options.filter(node)) {
      return null;
    }
    return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode, options)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
  }

  // node_modules/html-to-image/es/embed-resources.js
  var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
  var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
  var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  function toRegex(url) {
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
  }
  function parseURLs(cssText) {
    const urls = [];
    cssText.replace(URL_REGEX, (raw, quotation, url) => {
      urls.push(url);
      return raw;
    });
    return urls.filter((url) => !isDataUrl(url));
  }
  async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
    try {
      const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
      const contentType = getMimeType(resourceURL);
      let dataURL;
      if (getContentFromUrl) {
        const content = await getContentFromUrl(resolvedURL);
        dataURL = makeDataUrl(content, contentType);
      } else {
        dataURL = await resourceToDataURL(resolvedURL, contentType, options);
      }
      return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
    } catch (error) {
    }
    return cssText;
  }
  function filterPreferredFontFormat(str2, { preferredFontFormat }) {
    return !preferredFontFormat ? str2 : str2.replace(FONT_SRC_REGEX, (match) => {
      while (true) {
        const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
        if (!format) {
          return "";
        }
        if (format === preferredFontFormat) {
          return `src: ${src};`;
        }
      }
    });
  }
  function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
  }
  async function embedResources(cssText, baseUrl, options) {
    if (!shouldEmbed(cssText)) {
      return cssText;
    }
    const filteredCSSText = filterPreferredFontFormat(cssText, options);
    const urls = parseURLs(filteredCSSText);
    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
  }

  // node_modules/html-to-image/es/embed-images.js
  async function embedProp(propName, node, options) {
    var _a;
    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
    if (propValue) {
      const cssString = await embedResources(propValue, null, options);
      node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
      return true;
    }
    return false;
  }
  async function embedBackground(clonedNode, options) {
    ;
    await embedProp("background", clonedNode, options) || await embedProp("background-image", clonedNode, options);
    await embedProp("mask", clonedNode, options) || await embedProp("-webkit-mask", clonedNode, options) || await embedProp("mask-image", clonedNode, options) || await embedProp("-webkit-mask-image", clonedNode, options);
  }
  async function embedImageNode(clonedNode, options) {
    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
    if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
      return;
    }
    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
    const dataURL = await resourceToDataURL(url, getMimeType(url), options);
    await new Promise((resolve, reject) => {
      clonedNode.onload = resolve;
      clonedNode.onerror = options.onImageErrorHandler ? (...attributes) => {
        try {
          resolve(options.onImageErrorHandler(...attributes));
        } catch (error) {
          reject(error);
        }
      } : reject;
      const image = clonedNode;
      if (image.decode) {
        image.decode = resolve;
      }
      if (image.loading === "lazy") {
        image.loading = "eager";
      }
      if (isImageElement) {
        clonedNode.srcset = "";
        clonedNode.src = dataURL;
      } else {
        clonedNode.href.baseVal = dataURL;
      }
    });
  }
  async function embedChildren(clonedNode, options) {
    const children = toArray2(clonedNode.childNodes);
    const deferreds = children.map((child) => embedImages(child, options));
    await Promise.all(deferreds).then(() => clonedNode);
  }
  async function embedImages(clonedNode, options) {
    if (isInstanceOfElement(clonedNode, Element)) {
      await embedBackground(clonedNode, options);
      await embedImageNode(clonedNode, options);
      await embedChildren(clonedNode, options);
    }
  }

  // node_modules/html-to-image/es/apply-style.js
  function applyStyle(node, options) {
    const { style } = node;
    if (options.backgroundColor) {
      style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
      style.width = `${options.width}px`;
    }
    if (options.height) {
      style.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
      Object.keys(manual).forEach((key) => {
        style[key] = manual[key];
      });
    }
    return node;
  }

  // node_modules/html-to-image/es/embed-webfonts.js
  var cssFetchCache = {};
  async function fetchCSS(url) {
    let cache2 = cssFetchCache[url];
    if (cache2 != null) {
      return cache2;
    }
    const res = await fetch(url);
    const cssText = await res.text();
    cache2 = { url, cssText };
    cssFetchCache[url] = cache2;
    return cache2;
  }
  async function embedFonts(data, options) {
    let cssText = data.cssText;
    const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
    const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
    const loadFonts = fontLocs.map(async (loc) => {
      let url = loc.replace(regexUrl, "$1");
      if (!url.startsWith("https://")) {
        url = new URL(url, data.url).href;
      }
      return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {
        cssText = cssText.replace(loc, `url(${result})`);
        return [loc, result];
      });
    });
    return Promise.all(loadFonts).then(() => cssText);
  }
  function parseCSS(source) {
    if (source == null) {
      return [];
    }
    const result = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    let cssText = source.replace(commentsRegex, "");
    const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
    while (true) {
      const matches = keyframesRegex.exec(cssText);
      if (matches === null) {
        break;
      }
      result.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, "");
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
    const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
    while (true) {
      let matches = importRegex.exec(cssText);
      if (matches === null) {
        matches = unifiedRegex.exec(cssText);
        if (matches === null) {
          break;
        } else {
          importRegex.lastIndex = unifiedRegex.lastIndex;
        }
      } else {
        unifiedRegex.lastIndex = importRegex.lastIndex;
      }
      result.push(matches[0]);
    }
    return result;
  }
  async function getCSSRules(styleSheets, options) {
    const ret = [];
    const deferreds = [];
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray2(sheet.cssRules || []).forEach((item, index) => {
            if (item.type === CSSRule.IMPORT_RULE) {
              let importIndex = index + 1;
              const url = item.href;
              const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
                try {
                  sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
                } catch (error) {
                  console.error("Error inserting rule from remote css", {
                    rule,
                    error
                  });
                }
              })).catch((e8) => {
                console.error("Error loading remote css", e8.toString());
              });
              deferreds.push(deferred);
            }
          });
        } catch (e8) {
          const inline = styleSheets.find((a3) => a3.href == null) || document.styleSheets[0];
          if (sheet.href != null) {
            deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              inline.insertRule(rule, inline.cssRules.length);
            })).catch((err) => {
              console.error("Error loading remote stylesheet", err);
            }));
          }
          console.error("Error inlining remote css file", e8);
        }
      }
    });
    return Promise.all(deferreds).then(() => {
      styleSheets.forEach((sheet) => {
        if ("cssRules" in sheet) {
          try {
            toArray2(sheet.cssRules || []).forEach((item) => {
              ret.push(item);
            });
          } catch (e8) {
            console.error(`Error while reading CSS rules from ${sheet.href}`, e8);
          }
        }
      });
      return ret;
    });
  }
  function getWebFontRules(cssRules) {
    return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
  }
  async function parseWebFontRules(node, options) {
    if (node.ownerDocument == null) {
      throw new Error("Provided element is not within a Document");
    }
    const styleSheets = toArray2(node.ownerDocument.styleSheets);
    const cssRules = await getCSSRules(styleSheets, options);
    return getWebFontRules(cssRules);
  }
  function normalizeFontFamily(font) {
    return font.trim().replace(/["']/g, "");
  }
  function getUsedFonts(node) {
    const fonts = /* @__PURE__ */ new Set();
    function traverse2(node2) {
      const fontFamily = node2.style.fontFamily || getComputedStyle(node2).fontFamily;
      fontFamily.split(",").forEach((font) => {
        fonts.add(normalizeFontFamily(font));
      });
      Array.from(node2.children).forEach((child) => {
        if (child instanceof HTMLElement) {
          traverse2(child);
        }
      });
    }
    traverse2(node);
    return fonts;
  }
  async function getWebFontCSS(node, options) {
    const rules = await parseWebFontRules(node, options);
    const usedFonts = getUsedFonts(node);
    const cssTexts = await Promise.all(rules.filter((rule) => usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map((rule) => {
      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
      return embedResources(rule.cssText, baseUrl, options);
    }));
    return cssTexts.join("\n");
  }
  async function embedWebFonts(clonedNode, options) {
    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
    if (cssText) {
      const styleNode = document.createElement("style");
      const sytleContent = document.createTextNode(cssText);
      styleNode.appendChild(sytleContent);
      if (clonedNode.firstChild) {
        clonedNode.insertBefore(styleNode, clonedNode.firstChild);
      } else {
        clonedNode.appendChild(styleNode);
      }
    }
  }

  // node_modules/html-to-image/es/index.js
  async function toSvg(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const clonedNode = await cloneNode(node, options, true);
    await embedWebFonts(clonedNode, options);
    await embedImages(clonedNode, options);
    applyStyle(clonedNode, options);
    const datauri = await nodeToDataURL(clonedNode, width, height);
    return datauri;
  }
  async function toCanvas(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const svg = await toSvg(node, options);
    const img = await createImage(svg);
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const ratio = options.pixelRatio || getPixelRatio();
    const canvasWidth = options.canvasWidth || width;
    const canvasHeight = options.canvasHeight || height;
    canvas.width = canvasWidth * ratio;
    canvas.height = canvasHeight * ratio;
    if (!options.skipAutoScale) {
      checkCanvasDimensions(canvas);
    }
    canvas.style.width = `${canvasWidth}`;
    canvas.style.height = `${canvasHeight}`;
    if (options.backgroundColor) {
      context.fillStyle = options.backgroundColor;
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    context.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas;
  }
  async function toPng(node, options = {}) {
    const canvas = await toCanvas(node, options);
    return canvas.toDataURL();
  }

  // node_modules/@trpc/client/dist/objectSpread2-BvkFp-_Y.mjs
  var __create = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i6 = 0, n8 = keys.length, key; i6 < n8; i6++) {
      key = keys[i6];
      if (!__hasOwnProp.call(to, key) && key !== except) __defProp2(to, key, {
        get: ((k2) => from[k2]).bind(null, key),
        enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var require_typeof = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js"(exports, module) {
    function _typeof$2(o8) {
      "@babel/helpers - typeof";
      return module.exports = _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
        return typeof o$1;
      } : function(o$1) {
        return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof$2(o8);
    }
    module.exports = _typeof$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_toPrimitive = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js"(exports, module) {
    var _typeof$1 = require_typeof()["default"];
    function toPrimitive$1(t6, r7) {
      if ("object" != _typeof$1(t6) || !t6) return t6;
      var e8 = t6[Symbol.toPrimitive];
      if (void 0 !== e8) {
        var i6 = e8.call(t6, r7 || "default");
        if ("object" != _typeof$1(i6)) return i6;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r7 ? String : Number)(t6);
    }
    module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_toPropertyKey = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey$1(t6) {
      var i6 = toPrimitive(t6, "string");
      return "symbol" == _typeof(i6) ? i6 : i6 + "";
    }
    module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_defineProperty = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e8, r7, t6) {
      return (r7 = toPropertyKey(r7)) in e8 ? Object.defineProperty(e8, r7, {
        value: t6,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e8[r7] = t6, e8;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_objectSpread2 = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function ownKeys(e8, r7) {
      var t6 = Object.keys(e8);
      if (Object.getOwnPropertySymbols) {
        var o8 = Object.getOwnPropertySymbols(e8);
        r7 && (o8 = o8.filter(function(r$1) {
          return Object.getOwnPropertyDescriptor(e8, r$1).enumerable;
        })), t6.push.apply(t6, o8);
      }
      return t6;
    }
    function _objectSpread2(e8) {
      for (var r7 = 1; r7 < arguments.length; r7++) {
        var t6 = null != arguments[r7] ? arguments[r7] : {};
        r7 % 2 ? ownKeys(Object(t6), true).forEach(function(r$1) {
          defineProperty(e8, r$1, t6[r$1]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e8, Object.getOwnPropertyDescriptors(t6)) : ownKeys(Object(t6)).forEach(function(r$1) {
          Object.defineProperty(e8, r$1, Object.getOwnPropertyDescriptor(t6, r$1));
        });
      }
      return e8;
    }
    module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });

  // node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs
  function observable(subscribe) {
    const self = {
      subscribe(observer) {
        let teardownRef = null;
        let isDone = false;
        let unsubscribed = false;
        let teardownImmediately = false;
        function unsubscribe() {
          if (teardownRef === null) {
            teardownImmediately = true;
            return;
          }
          if (unsubscribed) return;
          unsubscribed = true;
          if (typeof teardownRef === "function") teardownRef();
          else if (teardownRef) teardownRef.unsubscribe();
        }
        teardownRef = subscribe({
          next(value) {
            var _observer$next;
            if (isDone) return;
            (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);
          },
          error(err) {
            var _observer$error;
            if (isDone) return;
            isDone = true;
            (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);
            unsubscribe();
          },
          complete() {
            var _observer$complete;
            if (isDone) return;
            isDone = true;
            (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);
            unsubscribe();
          }
        });
        if (teardownImmediately) unsubscribe();
        return { unsubscribe };
      },
      pipe(...operations) {
        return operations.reduce(pipeReducer, self);
      }
    };
    return self;
  }
  function pipeReducer(prev, fn) {
    return fn(prev);
  }
  function observableToPromise(observable$1) {
    const ac = new AbortController();
    const promise = new Promise((resolve, reject) => {
      let isDone = false;
      function onDone() {
        if (isDone) return;
        isDone = true;
        obs$.unsubscribe();
      }
      ac.signal.addEventListener("abort", () => {
        reject(ac.signal.reason);
      });
      const obs$ = observable$1.subscribe({
        next(data) {
          isDone = true;
          resolve(data);
          onDone();
        },
        error(data) {
          reject(data);
        },
        complete() {
          ac.abort();
          onDone();
        }
      });
    });
    return promise;
  }

  // node_modules/@trpc/server/dist/observable-CUiPknO-.mjs
  function share(_opts) {
    return (source) => {
      let refCount = 0;
      let subscription = null;
      const observers = [];
      function startIfNeeded() {
        if (subscription) return;
        subscription = source.subscribe({
          next(value) {
            for (const observer of observers) {
              var _observer$next;
              (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);
            }
          },
          error(error) {
            for (const observer of observers) {
              var _observer$error;
              (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);
            }
          },
          complete() {
            for (const observer of observers) {
              var _observer$complete;
              (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);
            }
          }
        });
      }
      function resetIfNeeded() {
        if (refCount === 0 && subscription) {
          const _sub = subscription;
          subscription = null;
          _sub.unsubscribe();
        }
      }
      return observable((subscriber) => {
        refCount++;
        observers.push(subscriber);
        startIfNeeded();
        return { unsubscribe() {
          refCount--;
          resetIfNeeded();
          const index = observers.findIndex((v2) => v2 === subscriber);
          if (index > -1) observers.splice(index, 1);
        } };
      });
    };
  }
  var distinctUnsetMarker = Symbol();
  function behaviorSubject(initialValue) {
    let value = initialValue;
    const observerList = [];
    const addObserver = (observer) => {
      if (value !== void 0) observer.next(value);
      observerList.push(observer);
    };
    const removeObserver = (observer) => {
      observerList.splice(observerList.indexOf(observer), 1);
    };
    const obs = observable((observer) => {
      addObserver(observer);
      return () => {
        removeObserver(observer);
      };
    });
    obs.next = (nextValue) => {
      if (value === nextValue) return;
      value = nextValue;
      for (const observer of observerList) observer.next(nextValue);
    };
    obs.get = () => value;
    return obs;
  }

  // node_modules/@trpc/client/dist/splitLink-B7Cuf2c_.mjs
  function createChain(opts) {
    return observable((observer) => {
      function execute(index = 0, op = opts.op) {
        const next = opts.links[index];
        if (!next) throw new Error("No more links to execute - did you forget to add an ending link?");
        const subscription = next({
          op,
          next(nextOp) {
            const nextObserver = execute(index + 1, nextOp);
            return nextObserver;
          }
        });
        return subscription;
      }
      const obs$ = execute();
      return obs$.subscribe(observer);
    });
  }
  function asArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function splitLink(opts) {
    return (runtime) => {
      const yes = asArray(opts.true).map((link) => link(runtime));
      const no = asArray(opts.false).map((link) => link(runtime));
      return (props) => {
        return observable((observer) => {
          const links = opts.condition(props.op) ? yes : no;
          return createChain({
            op: props.op,
            links
          }).subscribe(observer);
        });
      };
    };
  }

  // node_modules/@trpc/server/dist/utils-DdbbrDku.mjs
  var TRPC_ERROR_CODES_BY_KEY = {
    PARSE_ERROR: -32700,
    BAD_REQUEST: -32600,
    INTERNAL_SERVER_ERROR: -32603,
    NOT_IMPLEMENTED: -32603,
    BAD_GATEWAY: -32603,
    SERVICE_UNAVAILABLE: -32603,
    GATEWAY_TIMEOUT: -32603,
    UNAUTHORIZED: -32001,
    PAYMENT_REQUIRED: -32002,
    FORBIDDEN: -32003,
    NOT_FOUND: -32004,
    METHOD_NOT_SUPPORTED: -32005,
    TIMEOUT: -32008,
    CONFLICT: -32009,
    PRECONDITION_FAILED: -32012,
    PAYLOAD_TOO_LARGE: -32013,
    UNSUPPORTED_MEDIA_TYPE: -32015,
    UNPROCESSABLE_CONTENT: -32022,
    TOO_MANY_REQUESTS: -32029,
    CLIENT_CLOSED_REQUEST: -32099
  };
  var retryableRpcCodes = [
    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,
    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,
    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,
    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR
  ];
  function isObject2(value) {
    return !!value && !Array.isArray(value) && typeof value === "object";
  }
  var run = (fn) => fn();
  function sleep(ms = 0) {
    return new Promise((res) => setTimeout(res, ms));
  }

  // node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs
  var __create2 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __commonJS2 = (cb, mod) => function() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i6 = 0, n8 = keys.length, key; i6 < n8; i6++) {
      key = keys[i6];
      if (!__hasOwnProp2.call(to, key) && key !== except) __defProp3(to, key, {
        get: ((k2) => from[k2]).bind(null, key),
        enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var noop = () => {
  };
  var freezeIfAvailable = (obj) => {
    if (Object.freeze) Object.freeze(obj);
  };
  function createInnerProxy(callback, path, memo) {
    var _memo$cacheKey;
    const cacheKey = path.join(".");
    (_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {
      get(_obj, key) {
        if (typeof key !== "string" || key === "then") return void 0;
        return createInnerProxy(callback, [...path, key], memo);
      },
      apply(_1, _2, args) {
        const lastOfPath = path[path.length - 1];
        let opts = {
          args,
          path
        };
        if (lastOfPath === "call") opts = {
          args: args.length >= 2 ? [args[1]] : [],
          path: path.slice(0, -1)
        };
        else if (lastOfPath === "apply") opts = {
          args: args.length >= 2 ? args[1] : [],
          path: path.slice(0, -1)
        };
        freezeIfAvailable(opts.args);
        freezeIfAvailable(opts.path);
        return callback(opts);
      }
    }));
    return memo[cacheKey];
  }
  var createRecursiveProxy = (callback) => createInnerProxy(callback, [], /* @__PURE__ */ Object.create(null));
  var createFlatProxy = (callback) => {
    return new Proxy(noop, { get(_obj, name) {
      if (name === "then") return void 0;
      return callback(name);
    } });
  };
  var require_typeof2 = __commonJS2({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js"(exports, module) {
    function _typeof$2(o8) {
      "@babel/helpers - typeof";
      return module.exports = _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
        return typeof o$1;
      } : function(o$1) {
        return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof$2(o8);
    }
    module.exports = _typeof$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_toPrimitive2 = __commonJS2({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js"(exports, module) {
    var _typeof$1 = require_typeof2()["default"];
    function toPrimitive$1(t6, r7) {
      if ("object" != _typeof$1(t6) || !t6) return t6;
      var e8 = t6[Symbol.toPrimitive];
      if (void 0 !== e8) {
        var i6 = e8.call(t6, r7 || "default");
        if ("object" != _typeof$1(i6)) return i6;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r7 ? String : Number)(t6);
    }
    module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_toPropertyKey2 = __commonJS2({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof2()["default"];
    var toPrimitive = require_toPrimitive2();
    function toPropertyKey$1(t6) {
      var i6 = toPrimitive(t6, "string");
      return "symbol" == _typeof(i6) ? i6 : i6 + "";
    }
    module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_defineProperty2 = __commonJS2({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey2();
    function _defineProperty(e8, r7, t6) {
      return (r7 = toPropertyKey(r7)) in e8 ? Object.defineProperty(e8, r7, {
        value: t6,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e8[r7] = t6, e8;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_objectSpread22 = __commonJS2({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js"(exports, module) {
    var defineProperty = require_defineProperty2();
    function ownKeys(e8, r7) {
      var t6 = Object.keys(e8);
      if (Object.getOwnPropertySymbols) {
        var o8 = Object.getOwnPropertySymbols(e8);
        r7 && (o8 = o8.filter(function(r$1) {
          return Object.getOwnPropertyDescriptor(e8, r$1).enumerable;
        })), t6.push.apply(t6, o8);
      }
      return t6;
    }
    function _objectSpread2(e8) {
      for (var r7 = 1; r7 < arguments.length; r7++) {
        var t6 = null != arguments[r7] ? arguments[r7] : {};
        r7 % 2 ? ownKeys(Object(t6), true).forEach(function(r$1) {
          defineProperty(e8, r$1, t6[r$1]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e8, Object.getOwnPropertyDescriptors(t6)) : ownKeys(Object(t6)).forEach(function(r$1) {
          Object.defineProperty(e8, r$1, Object.getOwnPropertyDescriptor(t6, r$1));
        });
      }
      return e8;
    }
    module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var import_objectSpread2 = __toESM2(require_objectSpread22(), 1);

  // node_modules/@trpc/server/dist/tracked-Bp72jHif.mjs
  var import_defineProperty = __toESM2(require_defineProperty2(), 1);
  var import_objectSpread2$1 = __toESM2(require_objectSpread22(), 1);
  function transformResultInner(response, transformer) {
    if ("error" in response) {
      const error = transformer.deserialize(response.error);
      return {
        ok: false,
        error: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response), {}, { error })
      };
    }
    const result = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response.result), (!response.result.type || response.result.type === "data") && {
      type: "data",
      data: transformer.deserialize(response.result.data)
    });
    return {
      ok: true,
      result
    };
  }
  var TransformResultError = class extends Error {
    constructor() {
      super("Unable to transform response from server");
    }
  };
  function transformResult(response, transformer) {
    let result;
    try {
      result = transformResultInner(response, transformer);
    } catch (_unused) {
      throw new TransformResultError();
    }
    if (!result.ok && (!isObject2(result.error.error) || typeof result.error.error["code"] !== "number")) throw new TransformResultError();
    if (result.ok && !isObject2(result.result)) throw new TransformResultError();
    return result;
  }
  var import_objectSpread22 = __toESM2(require_objectSpread22(), 1);
  var trackedSymbol = Symbol();

  // node_modules/@trpc/client/dist/TRPCClientError-CjKyS10w.mjs
  var import_defineProperty2 = __toESM(require_defineProperty(), 1);
  var import_objectSpread23 = __toESM(require_objectSpread2(), 1);
  function isTRPCClientError(cause) {
    return cause instanceof TRPCClientError;
  }
  function isTRPCErrorResponse(obj) {
    return isObject2(obj) && isObject2(obj["error"]) && typeof obj["error"]["code"] === "number" && typeof obj["error"]["message"] === "string";
  }
  function getMessageFromUnknownError(err, fallback) {
    if (typeof err === "string") return err;
    if (isObject2(err) && typeof err["message"] === "string") return err["message"];
    return fallback;
  }
  var TRPCClientError = class TRPCClientError2 extends Error {
    constructor(message, opts) {
      var _opts$result, _opts$result2;
      const cause = opts === null || opts === void 0 ? void 0 : opts.cause;
      super(message, { cause });
      (0, import_defineProperty2.default)(this, "cause", void 0);
      (0, import_defineProperty2.default)(this, "shape", void 0);
      (0, import_defineProperty2.default)(this, "data", void 0);
      (0, import_defineProperty2.default)(this, "meta", void 0);
      this.meta = opts === null || opts === void 0 ? void 0 : opts.meta;
      this.cause = cause;
      this.shape = opts === null || opts === void 0 || (_opts$result = opts.result) === null || _opts$result === void 0 ? void 0 : _opts$result.error;
      this.data = opts === null || opts === void 0 || (_opts$result2 = opts.result) === null || _opts$result2 === void 0 ? void 0 : _opts$result2.error.data;
      this.name = "TRPCClientError";
      Object.setPrototypeOf(this, TRPCClientError2.prototype);
    }
    static from(_cause, opts = {}) {
      const cause = _cause;
      if (isTRPCClientError(cause)) {
        if (opts.meta) cause.meta = (0, import_objectSpread23.default)((0, import_objectSpread23.default)({}, cause.meta), opts.meta);
        return cause;
      }
      if (isTRPCErrorResponse(cause)) return new TRPCClientError2(cause.error.message, (0, import_objectSpread23.default)((0, import_objectSpread23.default)({}, opts), {}, { result: cause }));
      return new TRPCClientError2(getMessageFromUnknownError(cause, "Unknown error"), (0, import_objectSpread23.default)((0, import_objectSpread23.default)({}, opts), {}, { cause }));
    }
  };

  // node_modules/@trpc/client/dist/unstable-internals-Bg7n9BBj.mjs
  function getTransformer(transformer) {
    const _transformer = transformer;
    if (!_transformer) return {
      input: {
        serialize: (data) => data,
        deserialize: (data) => data
      },
      output: {
        serialize: (data) => data,
        deserialize: (data) => data
      }
    };
    if ("input" in _transformer) return _transformer;
    return {
      input: _transformer,
      output: _transformer
    };
  }

  // node_modules/@trpc/client/dist/httpUtils-Bkv1johT.mjs
  var isFunction2 = (fn) => typeof fn === "function";
  function getFetch(customFetchImpl) {
    if (customFetchImpl) return customFetchImpl;
    if (typeof window !== "undefined" && isFunction2(window.fetch)) return window.fetch;
    if (typeof globalThis !== "undefined" && isFunction2(globalThis.fetch)) return globalThis.fetch;
    throw new Error("No fetch implementation found");
  }
  var import_objectSpread24 = __toESM(require_objectSpread2(), 1);
  function resolveHTTPLinkOptions(opts) {
    return {
      url: opts.url.toString(),
      fetch: opts.fetch,
      transformer: getTransformer(opts.transformer),
      methodOverride: opts.methodOverride
    };
  }
  function arrayToDict(array) {
    const dict = {};
    for (let index = 0; index < array.length; index++) {
      const element = array[index];
      dict[index] = element;
    }
    return dict;
  }
  var METHOD = {
    query: "GET",
    mutation: "POST",
    subscription: "PATCH"
  };
  function getInput(opts) {
    return "input" in opts ? opts.transformer.input.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.transformer.input.serialize(_input)));
  }
  var getUrl = (opts) => {
    const parts = opts.url.split("?");
    const base = parts[0].replace(/\/$/, "");
    let url = base + "/" + opts.path;
    const queryParts = [];
    if (parts[1]) queryParts.push(parts[1]);
    if ("inputs" in opts) queryParts.push("batch=1");
    if (opts.type === "query" || opts.type === "subscription") {
      const input = getInput(opts);
      if (input !== void 0 && opts.methodOverride !== "POST") queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
    if (queryParts.length) url += "?" + queryParts.join("&");
    return url;
  };
  var getBody = (opts) => {
    if (opts.type === "query" && opts.methodOverride !== "POST") return void 0;
    const input = getInput(opts);
    return input !== void 0 ? JSON.stringify(input) : void 0;
  };
  var jsonHttpRequester = (opts) => {
    return httpRequest((0, import_objectSpread24.default)((0, import_objectSpread24.default)({}, opts), {}, {
      contentTypeHeader: "application/json",
      getUrl,
      getBody
    }));
  };
  var AbortError = class extends Error {
    constructor() {
      const name = "AbortError";
      super(name);
      this.name = name;
      this.message = name;
    }
  };
  var throwIfAborted = (signal) => {
    var _signal$throwIfAborte;
    if (!(signal === null || signal === void 0 ? void 0 : signal.aborted)) return;
    (_signal$throwIfAborte = signal.throwIfAborted) === null || _signal$throwIfAborte === void 0 || _signal$throwIfAborte.call(signal);
    if (typeof DOMException !== "undefined") throw new DOMException("AbortError", "AbortError");
    throw new AbortError();
  };
  async function fetchHTTPResponse(opts) {
    var _opts$methodOverride;
    throwIfAborted(opts.signal);
    const url = opts.getUrl(opts);
    const body = opts.getBody(opts);
    const { type: type2 } = opts;
    const resolvedHeaders = await (async () => {
      const heads = await opts.headers();
      if (Symbol.iterator in heads) return Object.fromEntries(heads);
      return heads;
    })();
    const headers = (0, import_objectSpread24.default)((0, import_objectSpread24.default)((0, import_objectSpread24.default)({}, opts.contentTypeHeader ? { "content-type": opts.contentTypeHeader } : {}), opts.trpcAcceptHeader ? { "trpc-accept": opts.trpcAcceptHeader } : void 0), resolvedHeaders);
    return getFetch(opts.fetch)(url, {
      method: (_opts$methodOverride = opts.methodOverride) !== null && _opts$methodOverride !== void 0 ? _opts$methodOverride : METHOD[type2],
      signal: opts.signal,
      body,
      headers
    });
  }
  async function httpRequest(opts) {
    const meta = {};
    const res = await fetchHTTPResponse(opts);
    meta.response = res;
    const json2 = await res.json();
    meta.responseJSON = json2;
    return {
      json: json2,
      meta
    };
  }

  // node_modules/@trpc/client/dist/httpLink-CYOcG9kQ.mjs
  var import_objectSpread25 = __toESM(require_objectSpread2(), 1);

  // node_modules/@trpc/client/dist/httpBatchLink-CA96-gnJ.mjs
  var throwFatalError = () => {
    throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
  };
  function dataLoader(batchLoader) {
    let pendingItems = null;
    let dispatchTimer = null;
    const destroyTimerAndPendingItems = () => {
      clearTimeout(dispatchTimer);
      dispatchTimer = null;
      pendingItems = null;
    };
    function groupItems(items) {
      const groupedItems = [[]];
      let index = 0;
      while (true) {
        const item = items[index];
        if (!item) break;
        const lastGroup = groupedItems[groupedItems.length - 1];
        if (item.aborted) {
          var _item$reject;
          (_item$reject = item.reject) === null || _item$reject === void 0 || _item$reject.call(item, new Error("Aborted"));
          index++;
          continue;
        }
        const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
        if (isValid) {
          lastGroup.push(item);
          index++;
          continue;
        }
        if (lastGroup.length === 0) {
          var _item$reject2;
          (_item$reject2 = item.reject) === null || _item$reject2 === void 0 || _item$reject2.call(item, new Error("Input is too big for a single dispatch"));
          index++;
          continue;
        }
        groupedItems.push([]);
      }
      return groupedItems;
    }
    function dispatch() {
      const groupedItems = groupItems(pendingItems);
      destroyTimerAndPendingItems();
      for (const items of groupedItems) {
        if (!items.length) continue;
        const batch = { items };
        for (const item of items) item.batch = batch;
        const promise = batchLoader.fetch(batch.items.map((_item) => _item.key));
        promise.then(async (result) => {
          await Promise.all(result.map(async (valueOrPromise, index) => {
            const item = batch.items[index];
            try {
              var _item$resolve;
              const value = await Promise.resolve(valueOrPromise);
              (_item$resolve = item.resolve) === null || _item$resolve === void 0 || _item$resolve.call(item, value);
            } catch (cause) {
              var _item$reject3;
              (_item$reject3 = item.reject) === null || _item$reject3 === void 0 || _item$reject3.call(item, cause);
            }
            item.batch = null;
            item.reject = null;
            item.resolve = null;
          }));
          for (const item of batch.items) {
            var _item$reject4;
            (_item$reject4 = item.reject) === null || _item$reject4 === void 0 || _item$reject4.call(item, new Error("Missing result"));
            item.batch = null;
          }
        }).catch((cause) => {
          for (const item of batch.items) {
            var _item$reject5;
            (_item$reject5 = item.reject) === null || _item$reject5 === void 0 || _item$reject5.call(item, cause);
            item.batch = null;
          }
        });
      }
    }
    function load2(key) {
      var _dispatchTimer;
      const item = {
        aborted: false,
        key,
        batch: null,
        resolve: throwFatalError,
        reject: throwFatalError
      };
      const promise = new Promise((resolve, reject) => {
        var _pendingItems;
        item.reject = reject;
        item.resolve = resolve;
        (_pendingItems = pendingItems) !== null && _pendingItems !== void 0 || (pendingItems = []);
        pendingItems.push(item);
      });
      (_dispatchTimer = dispatchTimer) !== null && _dispatchTimer !== void 0 || (dispatchTimer = setTimeout(dispatch));
      return promise;
    }
    return { load: load2 };
  }
  function allAbortSignals(...signals) {
    const ac = new AbortController();
    const count = signals.length;
    let abortedCount = 0;
    const onAbort = () => {
      if (++abortedCount === count) ac.abort();
    };
    for (const signal of signals) if (signal === null || signal === void 0 ? void 0 : signal.aborted) onAbort();
    else signal === null || signal === void 0 || signal.addEventListener("abort", onAbort, { once: true });
    return ac.signal;
  }
  var import_objectSpread26 = __toESM(require_objectSpread2(), 1);
  function httpBatchLink(opts) {
    var _opts$maxURLLength, _opts$maxItems;
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = (_opts$maxURLLength = opts.maxURLLength) !== null && _opts$maxURLLength !== void 0 ? _opts$maxURLLength : Infinity;
    const maxItems = (_opts$maxItems = opts.maxItems) !== null && _opts$maxItems !== void 0 ? _opts$maxItems : Infinity;
    return () => {
      const batchLoader = (type2) => {
        return {
          validate(batchOps) {
            if (maxURLLength === Infinity && maxItems === Infinity) return true;
            if (batchOps.length > maxItems) return false;
            const path = batchOps.map((op) => op.path).join(",");
            const inputs = batchOps.map((op) => op.input);
            const url = getUrl((0, import_objectSpread26.default)((0, import_objectSpread26.default)({}, resolvedOpts), {}, {
              type: type2,
              path,
              inputs,
              signal: null
            }));
            return url.length <= maxURLLength;
          },
          async fetch(batchOps) {
            const path = batchOps.map((op) => op.path).join(",");
            const inputs = batchOps.map((op) => op.input);
            const signal = allAbortSignals(...batchOps.map((op) => op.signal));
            const res = await jsonHttpRequester((0, import_objectSpread26.default)((0, import_objectSpread26.default)({}, resolvedOpts), {}, {
              path,
              inputs,
              type: type2,
              headers() {
                if (!opts.headers) return {};
                if (typeof opts.headers === "function") return opts.headers({ opList: batchOps });
                return opts.headers;
              },
              signal
            }));
            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
            const result = resJSON.map((item) => ({
              meta: res.meta,
              json: item
            }));
            return result;
          }
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const loaders = {
        query,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          if (op.type === "subscription") throw new Error("Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`");
          const loader2 = loaders[op.type];
          const promise = loader2.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, resolvedOpts.transformer.output);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, { meta: res.meta }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, { meta: _res === null || _res === void 0 ? void 0 : _res.meta }));
          });
          return () => {
          };
        });
      };
    };
  }

  // node_modules/@trpc/client/dist/loggerLink-ineCN1PO.mjs
  var import_objectSpread27 = __toESM(require_objectSpread2(), 1);

  // node_modules/@trpc/client/dist/wsLink-H5IjZfJW.mjs
  var lazyDefaults = {
    enabled: false,
    closeMs: 0
  };
  var keepAliveDefaults = {
    enabled: false,
    pongTimeoutMs: 1e3,
    intervalMs: 5e3
  };
  var exponentialBackoff = (attemptIndex) => {
    return attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
  };
  var resultOf = (value, ...args) => {
    return typeof value === "function" ? value(...args) : value;
  };
  var import_defineProperty$3 = __toESM(require_defineProperty(), 1);
  var TRPCWebSocketClosedError = class TRPCWebSocketClosedError2 extends Error {
    constructor(opts) {
      super(opts.message, { cause: opts.cause });
      this.name = "TRPCWebSocketClosedError";
      Object.setPrototypeOf(this, TRPCWebSocketClosedError2.prototype);
    }
  };
  var ResettableTimeout = class {
    constructor(onTimeout, timeoutMs) {
      this.onTimeout = onTimeout;
      this.timeoutMs = timeoutMs;
      (0, import_defineProperty$3.default)(this, "timeout", void 0);
    }
    /**
    * Resets the current timeout, restarting it with the same duration.
    * Does nothing if no timeout is active.
    */
    reset() {
      if (!this.timeout) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(this.onTimeout, this.timeoutMs);
    }
    start() {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(this.onTimeout, this.timeoutMs);
    }
    stop() {
      clearTimeout(this.timeout);
      this.timeout = void 0;
    }
  };
  function withResolvers() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return {
      promise,
      resolve,
      reject
    };
  }
  async function prepareUrl(urlOptions) {
    const url = await resultOf(urlOptions.url);
    if (!urlOptions.connectionParams) return url;
    const prefix = url.includes("?") ? "&" : "?";
    const connectionParams = `${prefix}connectionParams=1`;
    return url + connectionParams;
  }
  async function buildConnectionMessage(connectionParams) {
    const message = {
      method: "connectionParams",
      data: await resultOf(connectionParams)
    };
    return JSON.stringify(message);
  }
  var import_defineProperty$2 = __toESM(require_defineProperty(), 1);
  var RequestManager = class {
    constructor() {
      (0, import_defineProperty$2.default)(this, "outgoingRequests", new Array());
      (0, import_defineProperty$2.default)(this, "pendingRequests", {});
    }
    /**
    * Registers a new request by adding it to the outgoing queue and setting up
    * callbacks for lifecycle events such as completion or error.
    *
    * @param message - The outgoing message to be sent.
    * @param callbacks - Callback functions to observe the request's state.
    * @returns A cleanup function to manually remove the request.
    */
    register(message, callbacks) {
      const { promise: end, resolve } = withResolvers();
      this.outgoingRequests.push({
        id: String(message.id),
        message,
        end,
        callbacks: {
          next: callbacks.next,
          complete: () => {
            callbacks.complete();
            resolve();
          },
          error: (e8) => {
            callbacks.error(e8);
            resolve();
          }
        }
      });
      return () => {
        this.delete(message.id);
        callbacks.complete();
        resolve();
      };
    }
    /**
    * Deletes a request from both the outgoing and pending collections, if it exists.
    */
    delete(messageId) {
      if (messageId === null) return;
      this.outgoingRequests = this.outgoingRequests.filter(({ id }) => id !== String(messageId));
      delete this.pendingRequests[String(messageId)];
    }
    /**
    * Moves all outgoing requests to the pending state and clears the outgoing queue.
    *
    * The caller is expected to handle the actual sending of the requests
    * (e.g., sending them over the network) after this method is called.
    *
    * @returns The list of requests that were transitioned to the pending state.
    */
    flush() {
      const requests = this.outgoingRequests;
      this.outgoingRequests = [];
      for (const request of requests) this.pendingRequests[request.id] = request;
      return requests;
    }
    /**
    * Retrieves all currently pending requests, which are in flight awaiting responses
    * or handling ongoing subscriptions.
    */
    getPendingRequests() {
      return Object.values(this.pendingRequests);
    }
    /**
    * Retrieves a specific pending request by its message ID.
    */
    getPendingRequest(messageId) {
      if (messageId === null) return null;
      return this.pendingRequests[String(messageId)];
    }
    /**
    * Retrieves all outgoing requests, which are waiting to be sent.
    */
    getOutgoingRequests() {
      return this.outgoingRequests;
    }
    /**
    * Retrieves all requests, both outgoing and pending, with their respective states.
    *
    * @returns An array of all requests with their state ("outgoing" or "pending").
    */
    getRequests() {
      return [...this.getOutgoingRequests().map((request) => ({
        state: "outgoing",
        message: request.message,
        end: request.end,
        callbacks: request.callbacks
      })), ...this.getPendingRequests().map((request) => ({
        state: "pending",
        message: request.message,
        end: request.end,
        callbacks: request.callbacks
      }))];
    }
    /**
    * Checks if there are any pending requests, including ongoing subscriptions.
    */
    hasPendingRequests() {
      return this.getPendingRequests().length > 0;
    }
    /**
    * Checks if there are any pending subscriptions
    */
    hasPendingSubscriptions() {
      return this.getPendingRequests().some((request) => request.message.method === "subscription");
    }
    /**
    * Checks if there are any outgoing requests waiting to be sent.
    */
    hasOutgoingRequests() {
      return this.outgoingRequests.length > 0;
    }
  };
  var import_defineProperty$1 = __toESM(require_defineProperty(), 1);
  function asyncWsOpen(ws) {
    const { promise, resolve, reject } = withResolvers();
    ws.addEventListener("open", () => {
      ws.removeEventListener("error", reject);
      resolve();
    });
    ws.addEventListener("error", reject);
    return promise;
  }
  function setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {
    let pingTimeout;
    let pongTimeout;
    function start() {
      pingTimeout = setTimeout(() => {
        ws.send("PING");
        pongTimeout = setTimeout(() => {
          ws.close();
        }, pongTimeoutMs);
      }, intervalMs);
    }
    function reset() {
      clearTimeout(pingTimeout);
      start();
    }
    function pong() {
      clearTimeout(pongTimeout);
      reset();
    }
    ws.addEventListener("open", start);
    ws.addEventListener("message", ({ data }) => {
      clearTimeout(pingTimeout);
      start();
      if (data === "PONG") pong();
    });
    ws.addEventListener("close", () => {
      clearTimeout(pingTimeout);
      clearTimeout(pongTimeout);
    });
  }
  var WsConnection = class WsConnection2 {
    constructor(opts) {
      var _opts$WebSocketPonyfi;
      (0, import_defineProperty$1.default)(this, "id", ++WsConnection2.connectCount);
      (0, import_defineProperty$1.default)(this, "WebSocketPonyfill", void 0);
      (0, import_defineProperty$1.default)(this, "urlOptions", void 0);
      (0, import_defineProperty$1.default)(this, "keepAliveOpts", void 0);
      (0, import_defineProperty$1.default)(this, "wsObservable", behaviorSubject(null));
      (0, import_defineProperty$1.default)(this, "openPromise", null);
      this.WebSocketPonyfill = (_opts$WebSocketPonyfi = opts.WebSocketPonyfill) !== null && _opts$WebSocketPonyfi !== void 0 ? _opts$WebSocketPonyfi : WebSocket;
      if (!this.WebSocketPonyfill) throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
      this.urlOptions = opts.urlOptions;
      this.keepAliveOpts = opts.keepAlive;
    }
    get ws() {
      return this.wsObservable.get();
    }
    set ws(ws) {
      this.wsObservable.next(ws);
    }
    /**
    * Checks if the WebSocket connection is open and ready to communicate.
    */
    isOpen() {
      return !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;
    }
    /**
    * Checks if the WebSocket connection is closed or in the process of closing.
    */
    isClosed() {
      return !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);
    }
    async open() {
      var _this = this;
      if (_this.openPromise) return _this.openPromise;
      _this.id = ++WsConnection2.connectCount;
      const wsPromise = prepareUrl(_this.urlOptions).then((url) => new _this.WebSocketPonyfill(url));
      _this.openPromise = wsPromise.then(async (ws) => {
        _this.ws = ws;
        ws.addEventListener("message", function({ data }) {
          if (data === "PING") this.send("PONG");
        });
        if (_this.keepAliveOpts.enabled) setupPingInterval(ws, _this.keepAliveOpts);
        ws.addEventListener("close", () => {
          if (_this.ws === ws) _this.ws = null;
        });
        await asyncWsOpen(ws);
        if (_this.urlOptions.connectionParams) ws.send(await buildConnectionMessage(_this.urlOptions.connectionParams));
      });
      try {
        await _this.openPromise;
      } finally {
        _this.openPromise = null;
      }
    }
    /**
    * Closes the WebSocket connection gracefully.
    * Waits for any ongoing open operation to complete before closing.
    */
    async close() {
      var _this2 = this;
      try {
        await _this2.openPromise;
      } finally {
        var _this$ws;
        (_this$ws = _this2.ws) === null || _this$ws === void 0 || _this$ws.close();
      }
    }
  };
  (0, import_defineProperty$1.default)(WsConnection, "connectCount", 0);
  function backwardCompatibility(connection) {
    if (connection.isOpen()) return {
      id: connection.id,
      state: "open",
      ws: connection.ws
    };
    if (connection.isClosed()) return {
      id: connection.id,
      state: "closed",
      ws: connection.ws
    };
    if (!connection.ws) return null;
    return {
      id: connection.id,
      state: "connecting",
      ws: connection.ws
    };
  }
  var import_defineProperty3 = __toESM(require_defineProperty(), 1);
  var import_objectSpread28 = __toESM(require_objectSpread2(), 1);
  var WsClient = class {
    constructor(opts) {
      var _opts$retryDelayMs;
      (0, import_defineProperty3.default)(this, "connectionState", void 0);
      (0, import_defineProperty3.default)(this, "allowReconnect", false);
      (0, import_defineProperty3.default)(this, "requestManager", new RequestManager());
      (0, import_defineProperty3.default)(this, "activeConnection", void 0);
      (0, import_defineProperty3.default)(this, "reconnectRetryDelay", void 0);
      (0, import_defineProperty3.default)(this, "inactivityTimeout", void 0);
      (0, import_defineProperty3.default)(this, "callbacks", void 0);
      (0, import_defineProperty3.default)(this, "lazyMode", void 0);
      (0, import_defineProperty3.default)(this, "reconnecting", null);
      this.callbacks = {
        onOpen: opts.onOpen,
        onClose: opts.onClose,
        onError: opts.onError
      };
      const lazyOptions = (0, import_objectSpread28.default)((0, import_objectSpread28.default)({}, lazyDefaults), opts.lazy);
      this.inactivityTimeout = new ResettableTimeout(() => {
        if (this.requestManager.hasOutgoingRequests() || this.requestManager.hasPendingRequests()) {
          this.inactivityTimeout.reset();
          return;
        }
        this.close().catch(() => null);
      }, lazyOptions.closeMs);
      this.activeConnection = new WsConnection({
        WebSocketPonyfill: opts.WebSocket,
        urlOptions: opts,
        keepAlive: (0, import_objectSpread28.default)((0, import_objectSpread28.default)({}, keepAliveDefaults), opts.keepAlive)
      });
      this.activeConnection.wsObservable.subscribe({ next: (ws) => {
        if (!ws) return;
        this.setupWebSocketListeners(ws);
      } });
      this.reconnectRetryDelay = (_opts$retryDelayMs = opts.retryDelayMs) !== null && _opts$retryDelayMs !== void 0 ? _opts$retryDelayMs : exponentialBackoff;
      this.lazyMode = lazyOptions.enabled;
      this.connectionState = behaviorSubject({
        type: "state",
        state: lazyOptions.enabled ? "idle" : "connecting",
        error: null
      });
      if (!this.lazyMode) this.open().catch(() => null);
    }
    /**
    * Opens the WebSocket connection. Handles reconnection attempts and updates
    * the connection state accordingly.
    */
    async open() {
      var _this = this;
      _this.allowReconnect = true;
      if (_this.connectionState.get().state !== "connecting") _this.connectionState.next({
        type: "state",
        state: "connecting",
        error: null
      });
      try {
        await _this.activeConnection.open();
      } catch (error) {
        _this.reconnect(new TRPCWebSocketClosedError({
          message: "Initialization error",
          cause: error
        }));
        return _this.reconnecting;
      }
    }
    /**
    * Closes the WebSocket connection and stops managing requests.
    * Ensures all outgoing and pending requests are properly finalized.
    */
    async close() {
      var _this2 = this;
      _this2.allowReconnect = false;
      _this2.inactivityTimeout.stop();
      const requestsToAwait = [];
      for (const request of _this2.requestManager.getRequests()) if (request.message.method === "subscription") request.callbacks.complete();
      else if (request.state === "outgoing") request.callbacks.error(TRPCClientError.from(new TRPCWebSocketClosedError({ message: "Closed before connection was established" })));
      else requestsToAwait.push(request.end);
      await Promise.all(requestsToAwait).catch(() => null);
      await _this2.activeConnection.close().catch(() => null);
      _this2.connectionState.next({
        type: "state",
        state: "idle",
        error: null
      });
    }
    /**
    * Method to request the server.
    * Handles data transformation, batching of requests, and subscription lifecycle.
    *
    * @param op - The operation details including id, type, path, input and signal
    * @param transformer - Data transformer for serializing requests and deserializing responses
    * @param lastEventId - Optional ID of the last received event for subscriptions
    *
    * @returns An observable that emits operation results and handles cleanup
    */
    request({ op: { id, type: type2, path, input, signal }, transformer, lastEventId }) {
      return observable((observer) => {
        const abort = this.batchSend({
          id,
          method: type2,
          params: {
            input: transformer.input.serialize(input),
            path,
            lastEventId
          }
        }, (0, import_objectSpread28.default)((0, import_objectSpread28.default)({}, observer), {}, { next(event) {
          const transformed = transformResult(event, transformer.output);
          if (!transformed.ok) {
            observer.error(TRPCClientError.from(transformed.error));
            return;
          }
          observer.next({ result: transformed.result });
        } }));
        return () => {
          abort();
          if (type2 === "subscription" && this.activeConnection.isOpen()) this.send({
            id,
            method: "subscription.stop"
          });
          signal === null || signal === void 0 || signal.removeEventListener("abort", abort);
        };
      });
    }
    get connection() {
      return backwardCompatibility(this.activeConnection);
    }
    reconnect(closedError) {
      var _this3 = this;
      this.connectionState.next({
        type: "state",
        state: "connecting",
        error: TRPCClientError.from(closedError)
      });
      if (this.reconnecting) return;
      const tryReconnect = async (attemptIndex) => {
        try {
          await sleep(_this3.reconnectRetryDelay(attemptIndex));
          if (_this3.allowReconnect) {
            await _this3.activeConnection.close();
            await _this3.activeConnection.open();
            if (_this3.requestManager.hasPendingRequests()) _this3.send(_this3.requestManager.getPendingRequests().map(({ message }) => message));
          }
          _this3.reconnecting = null;
        } catch (_unused) {
          await tryReconnect(attemptIndex + 1);
        }
      };
      this.reconnecting = tryReconnect(0);
    }
    setupWebSocketListeners(ws) {
      var _this4 = this;
      const handleCloseOrError = (cause) => {
        const reqs = this.requestManager.getPendingRequests();
        for (const { message, callbacks } of reqs) {
          if (message.method === "subscription") continue;
          callbacks.error(TRPCClientError.from(cause !== null && cause !== void 0 ? cause : new TRPCWebSocketClosedError({
            message: "WebSocket closed",
            cause
          })));
          this.requestManager.delete(message.id);
        }
      };
      ws.addEventListener("open", () => {
        run(async () => {
          var _this$callbacks$onOpe, _this$callbacks;
          if (_this4.lazyMode) _this4.inactivityTimeout.start();
          (_this$callbacks$onOpe = (_this$callbacks = _this4.callbacks).onOpen) === null || _this$callbacks$onOpe === void 0 || _this$callbacks$onOpe.call(_this$callbacks);
          _this4.connectionState.next({
            type: "state",
            state: "pending",
            error: null
          });
        }).catch((error) => {
          ws.close(3e3);
          handleCloseOrError(error);
        });
      });
      ws.addEventListener("message", ({ data }) => {
        this.inactivityTimeout.reset();
        if (typeof data !== "string" || ["PING", "PONG"].includes(data)) return;
        const incomingMessage = JSON.parse(data);
        if ("method" in incomingMessage) {
          this.handleIncomingRequest(incomingMessage);
          return;
        }
        this.handleResponseMessage(incomingMessage);
      });
      ws.addEventListener("close", (event) => {
        var _this$callbacks$onClo, _this$callbacks2;
        handleCloseOrError(event);
        (_this$callbacks$onClo = (_this$callbacks2 = this.callbacks).onClose) === null || _this$callbacks$onClo === void 0 || _this$callbacks$onClo.call(_this$callbacks2, event);
        if (!this.lazyMode || this.requestManager.hasPendingSubscriptions()) this.reconnect(new TRPCWebSocketClosedError({
          message: "WebSocket closed",
          cause: event
        }));
      });
      ws.addEventListener("error", (event) => {
        var _this$callbacks$onErr, _this$callbacks3;
        handleCloseOrError(event);
        (_this$callbacks$onErr = (_this$callbacks3 = this.callbacks).onError) === null || _this$callbacks$onErr === void 0 || _this$callbacks$onErr.call(_this$callbacks3, event);
        this.reconnect(new TRPCWebSocketClosedError({
          message: "WebSocket closed",
          cause: event
        }));
      });
    }
    handleResponseMessage(message) {
      const request = this.requestManager.getPendingRequest(message.id);
      if (!request) return;
      request.callbacks.next(message);
      let completed = true;
      if ("result" in message && request.message.method === "subscription") {
        if (message.result.type === "data") request.message.params.lastEventId = message.result.id;
        if (message.result.type !== "stopped") completed = false;
      }
      if (completed) {
        request.callbacks.complete();
        this.requestManager.delete(message.id);
      }
    }
    handleIncomingRequest(message) {
      if (message.method === "reconnect") this.reconnect(new TRPCWebSocketClosedError({ message: "Server requested reconnect" }));
    }
    /**
    * Sends a message or batch of messages directly to the server.
    */
    send(messageOrMessages) {
      if (!this.activeConnection.isOpen()) throw new Error("Active connection is not open");
      const messages = messageOrMessages instanceof Array ? messageOrMessages : [messageOrMessages];
      this.activeConnection.ws.send(JSON.stringify(messages.length === 1 ? messages[0] : messages));
    }
    /**
    * Groups requests for batch sending.
    *
    * @returns A function to abort the batched request.
    */
    batchSend(message, callbacks) {
      var _this5 = this;
      this.inactivityTimeout.reset();
      run(async () => {
        if (!_this5.activeConnection.isOpen()) await _this5.open();
        await sleep(0);
        if (!_this5.requestManager.hasOutgoingRequests()) return;
        _this5.send(_this5.requestManager.flush().map(({ message: message$1 }) => message$1));
      }).catch((err) => {
        this.requestManager.delete(message.id);
        callbacks.error(TRPCClientError.from(err));
      });
      return this.requestManager.register(message, callbacks);
    }
  };
  function createWSClient(opts) {
    return new WsClient(opts);
  }
  function wsLink(opts) {
    const { client } = opts;
    const transformer = getTransformer(opts.transformer);
    return () => {
      return ({ op }) => {
        return observable((observer) => {
          const connStateSubscription = op.type === "subscription" ? client.connectionState.subscribe({ next(result) {
            observer.next({
              result,
              context: op.context
            });
          } }) : null;
          const requestSubscription = client.request({
            op,
            transformer
          }).subscribe(observer);
          return () => {
            requestSubscription.unsubscribe();
            connStateSubscription === null || connStateSubscription === void 0 || connStateSubscription.unsubscribe();
          };
        });
      };
    };
  }

  // node_modules/@trpc/client/dist/index.mjs
  var import_defineProperty4 = __toESM(require_defineProperty(), 1);
  var import_objectSpread2$4 = __toESM(require_objectSpread2(), 1);
  var TRPCUntypedClient = class {
    constructor(opts) {
      (0, import_defineProperty4.default)(this, "links", void 0);
      (0, import_defineProperty4.default)(this, "runtime", void 0);
      (0, import_defineProperty4.default)(this, "requestId", void 0);
      this.requestId = 0;
      this.runtime = {};
      this.links = opts.links.map((link) => link(this.runtime));
    }
    $request(opts) {
      var _opts$context;
      const chain$ = createChain({
        links: this.links,
        op: (0, import_objectSpread2$4.default)((0, import_objectSpread2$4.default)({}, opts), {}, {
          context: (_opts$context = opts.context) !== null && _opts$context !== void 0 ? _opts$context : {},
          id: ++this.requestId
        })
      });
      return chain$.pipe(share());
    }
    async requestAsPromise(opts) {
      var _this = this;
      try {
        const req$ = _this.$request(opts);
        const envelope = await observableToPromise(req$);
        const data = envelope.result.data;
        return data;
      } catch (err) {
        throw TRPCClientError.from(err);
      }
    }
    query(path, input, opts) {
      return this.requestAsPromise({
        type: "query",
        path,
        input,
        context: opts === null || opts === void 0 ? void 0 : opts.context,
        signal: opts === null || opts === void 0 ? void 0 : opts.signal
      });
    }
    mutation(path, input, opts) {
      return this.requestAsPromise({
        type: "mutation",
        path,
        input,
        context: opts === null || opts === void 0 ? void 0 : opts.context,
        signal: opts === null || opts === void 0 ? void 0 : opts.signal
      });
    }
    subscription(path, input, opts) {
      const observable$ = this.$request({
        type: "subscription",
        path,
        input,
        context: opts.context,
        signal: opts.signal
      });
      return observable$.subscribe({
        next(envelope) {
          switch (envelope.result.type) {
            case "state": {
              var _opts$onConnectionSta;
              (_opts$onConnectionSta = opts.onConnectionStateChange) === null || _opts$onConnectionSta === void 0 || _opts$onConnectionSta.call(opts, envelope.result);
              break;
            }
            case "started": {
              var _opts$onStarted;
              (_opts$onStarted = opts.onStarted) === null || _opts$onStarted === void 0 || _opts$onStarted.call(opts, { context: envelope.context });
              break;
            }
            case "stopped": {
              var _opts$onStopped;
              (_opts$onStopped = opts.onStopped) === null || _opts$onStopped === void 0 || _opts$onStopped.call(opts);
              break;
            }
            case "data":
            case void 0: {
              var _opts$onData;
              (_opts$onData = opts.onData) === null || _opts$onData === void 0 || _opts$onData.call(opts, envelope.result.data);
              break;
            }
          }
        },
        error(err) {
          var _opts$onError;
          (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, err);
        },
        complete() {
          var _opts$onComplete;
          (_opts$onComplete = opts.onComplete) === null || _opts$onComplete === void 0 || _opts$onComplete.call(opts);
        }
      });
    }
  };
  var untypedClientSymbol = Symbol.for("trpc_untypedClient");
  var clientCallTypeMap = {
    query: "query",
    mutate: "mutation",
    subscribe: "subscription"
  };
  var clientCallTypeToProcedureType = (clientCallType) => {
    return clientCallTypeMap[clientCallType];
  };
  function createTRPCClientProxy(client) {
    const proxy = createRecursiveProxy(({ path, args }) => {
      const pathCopy = [...path];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
    return createFlatProxy((key) => {
      if (key === untypedClientSymbol) return client;
      return proxy[key];
    });
  }
  function createTRPCClient(opts) {
    const client = new TRPCUntypedClient(opts);
    const proxy = createTRPCClientProxy(client);
    return proxy;
  }
  var import_objectSpread2$3 = __toESM(require_objectSpread2(), 1);
  var import_objectSpread2$2 = __toESM(require_objectSpread2(), 1);
  var require_asyncIterator = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js"(exports, module) {
    function _asyncIterator$1(r7) {
      var n8, t6, o8, e8 = 2;
      for ("undefined" != typeof Symbol && (t6 = Symbol.asyncIterator, o8 = Symbol.iterator); e8--; ) {
        if (t6 && null != (n8 = r7[t6])) return n8.call(r7);
        if (o8 && null != (n8 = r7[o8])) return new AsyncFromSyncIterator(n8.call(r7));
        t6 = "@@asyncIterator", o8 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }
    function AsyncFromSyncIterator(r7) {
      function AsyncFromSyncIteratorContinuation(r$1) {
        if (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + " is not an object."));
        var n8 = r$1.done;
        return Promise.resolve(r$1.value).then(function(r$2) {
          return {
            value: r$2,
            done: n8
          };
        });
      }
      return AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {
        this.s = r$1, this.n = r$1.next;
      }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function next() {
          return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        "return": function _return(r$1) {
          var n8 = this.s["return"];
          return void 0 === n8 ? Promise.resolve({
            value: r$1,
            done: true
          }) : AsyncFromSyncIteratorContinuation(n8.apply(this.s, arguments));
        },
        "throw": function _throw(r$1) {
          var n8 = this.s["return"];
          return void 0 === n8 ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n8.apply(this.s, arguments));
        }
      }, new AsyncFromSyncIterator(r7);
    }
    module.exports = _asyncIterator$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var import_asyncIterator = __toESM(require_asyncIterator(), 1);
  var import_objectSpread2$12 = __toESM(require_objectSpread2(), 1);
  var require_usingCtx = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js"(exports, module) {
    function _usingCtx() {
      var r7 = "function" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {
        var n$1 = Error();
        return n$1.name = "SuppressedError", n$1.error = r$1, n$1.suppressed = e$1, n$1;
      }, e8 = {}, n8 = [];
      function using(r$1, e$1) {
        if (null != e$1) {
          if (Object(e$1) !== e$1) throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");
          if (r$1) var o8 = e$1[Symbol.asyncDispose || Symbol["for"]("Symbol.asyncDispose")];
          if (void 0 === o8 && (o8 = e$1[Symbol.dispose || Symbol["for"]("Symbol.dispose")], r$1)) var t6 = o8;
          if ("function" != typeof o8) throw new TypeError("Object is not disposable.");
          t6 && (o8 = function o$1() {
            try {
              t6.call(e$1);
            } catch (r$2) {
              return Promise.reject(r$2);
            }
          }), n8.push({
            v: e$1,
            d: o8,
            a: r$1
          });
        } else r$1 && n8.push({
          d: e$1,
          a: r$1
        });
        return e$1;
      }
      return {
        e: e8,
        u: using.bind(null, false),
        a: using.bind(null, true),
        d: function d3() {
          var o8, t6 = this.e, s5 = 0;
          function next() {
            for (; o8 = n8.pop(); ) try {
              if (!o8.a && 1 === s5) return s5 = 0, n8.push(o8), Promise.resolve().then(next);
              if (o8.d) {
                var r$1 = o8.d.call(o8.v);
                if (o8.a) return s5 |= 2, Promise.resolve(r$1).then(next, err);
              } else s5 |= 1;
            } catch (r$2) {
              return err(r$2);
            }
            if (1 === s5) return t6 !== e8 ? Promise.reject(t6) : Promise.resolve();
            if (t6 !== e8) throw t6;
          }
          function err(n$1) {
            return t6 = t6 !== e8 ? new r7(n$1, t6) : n$1, next();
          }
          return next();
        }
      };
    }
    module.exports = _usingCtx, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_OverloadYield = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js"(exports, module) {
    function _OverloadYield(e8, d3) {
      this.v = e8, this.k = d3;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_awaitAsyncGenerator = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js"(exports, module) {
    var OverloadYield$1 = require_OverloadYield();
    function _awaitAsyncGenerator$1(e8) {
      return new OverloadYield$1(e8, 0);
    }
    module.exports = _awaitAsyncGenerator$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var require_wrapAsyncGenerator = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    function _wrapAsyncGenerator$1(e8) {
      return function() {
        return new AsyncGenerator(e8.apply(this, arguments));
      };
    }
    function AsyncGenerator(e8) {
      var r7, t6;
      function resume(r$1, t$1) {
        try {
          var n8 = e8[r$1](t$1), o8 = n8.value, u3 = o8 instanceof OverloadYield;
          Promise.resolve(u3 ? o8.v : o8).then(function(t$2) {
            if (u3) {
              var i6 = "return" === r$1 ? "return" : "next";
              if (!o8.k || t$2.done) return resume(i6, t$2);
              t$2 = e8[i6](t$2).value;
            }
            settle(n8.done ? "return" : "normal", t$2);
          }, function(e$1) {
            resume("throw", e$1);
          });
        } catch (e$1) {
          settle("throw", e$1);
        }
      }
      function settle(e$1, n8) {
        switch (e$1) {
          case "return":
            r7.resolve({
              value: n8,
              done: true
            });
            break;
          case "throw":
            r7.reject(n8);
            break;
          default:
            r7.resolve({
              value: n8,
              done: false
            });
        }
        (r7 = r7.next) ? resume(r7.key, r7.arg) : t6 = null;
      }
      this._invoke = function(e$1, n8) {
        return new Promise(function(o8, u3) {
          var i6 = {
            key: e$1,
            arg: n8,
            resolve: o8,
            reject: u3,
            next: null
          };
          t6 ? t6 = t6.next = i6 : (r7 = t6 = i6, resume(e$1, n8));
        });
      }, "function" != typeof e8["return"] && (this["return"] = void 0);
    }
    AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
      return this;
    }, AsyncGenerator.prototype.next = function(e8) {
      return this._invoke("next", e8);
    }, AsyncGenerator.prototype["throw"] = function(e8) {
      return this._invoke("throw", e8);
    }, AsyncGenerator.prototype["return"] = function(e8) {
      return this._invoke("return", e8);
    };
    module.exports = _wrapAsyncGenerator$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } });
  var import_usingCtx = __toESM(require_usingCtx(), 1);
  var import_awaitAsyncGenerator = __toESM(require_awaitAsyncGenerator(), 1);
  var import_wrapAsyncGenerator = __toESM(require_wrapAsyncGenerator(), 1);
  var import_objectSpread29 = __toESM(require_objectSpread2(), 1);

  // node_modules/superjson/dist/double-indexed-kv.js
  var DoubleIndexedKV = class {
    constructor() {
      this.keyToValue = /* @__PURE__ */ new Map();
      this.valueToKey = /* @__PURE__ */ new Map();
    }
    set(key, value) {
      this.keyToValue.set(key, value);
      this.valueToKey.set(value, key);
    }
    getByKey(key) {
      return this.keyToValue.get(key);
    }
    getByValue(value) {
      return this.valueToKey.get(value);
    }
    clear() {
      this.keyToValue.clear();
      this.valueToKey.clear();
    }
  };

  // node_modules/superjson/dist/registry.js
  var Registry = class {
    constructor(generateIdentifier) {
      this.generateIdentifier = generateIdentifier;
      this.kv = new DoubleIndexedKV();
    }
    register(value, identifier) {
      if (this.kv.getByValue(value)) {
        return;
      }
      if (!identifier) {
        identifier = this.generateIdentifier(value);
      }
      this.kv.set(identifier, value);
    }
    clear() {
      this.kv.clear();
    }
    getIdentifier(value) {
      return this.kv.getByValue(value);
    }
    getValue(identifier) {
      return this.kv.getByKey(identifier);
    }
  };

  // node_modules/superjson/dist/class-registry.js
  var ClassRegistry = class extends Registry {
    constructor() {
      super((c5) => c5.name);
      this.classToAllowedProps = /* @__PURE__ */ new Map();
    }
    register(value, options) {
      if (typeof options === "object") {
        if (options.allowProps) {
          this.classToAllowedProps.set(value, options.allowProps);
        }
        super.register(value, options.identifier);
      } else {
        super.register(value, options);
      }
    }
    getAllowedProps(value) {
      return this.classToAllowedProps.get(value);
    }
  };

  // node_modules/superjson/dist/util.js
  function valuesOfObj(record) {
    if ("values" in Object) {
      return Object.values(record);
    }
    const values = [];
    for (const key in record) {
      if (record.hasOwnProperty(key)) {
        values.push(record[key]);
      }
    }
    return values;
  }
  function find(record, predicate) {
    const values = valuesOfObj(record);
    if ("find" in values) {
      return values.find(predicate);
    }
    const valuesNotNever = values;
    for (let i6 = 0; i6 < valuesNotNever.length; i6++) {
      const value = valuesNotNever[i6];
      if (predicate(value)) {
        return value;
      }
    }
    return void 0;
  }
  function forEach(record, run2) {
    Object.entries(record).forEach(([key, value]) => run2(value, key));
  }
  function includes(arr, value) {
    return arr.indexOf(value) !== -1;
  }
  function findArr(record, predicate) {
    for (let i6 = 0; i6 < record.length; i6++) {
      const value = record[i6];
      if (predicate(value)) {
        return value;
      }
    }
    return void 0;
  }

  // node_modules/superjson/dist/custom-transformer-registry.js
  var CustomTransformerRegistry = class {
    constructor() {
      this.transfomers = {};
    }
    register(transformer) {
      this.transfomers[transformer.name] = transformer;
    }
    findApplicable(v2) {
      return find(this.transfomers, (transformer) => transformer.isApplicable(v2));
    }
    findByName(name) {
      return this.transfomers[name];
    }
  };

  // node_modules/superjson/dist/is.js
  var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
  var isUndefined = (payload) => typeof payload === "undefined";
  var isNull2 = (payload) => payload === null;
  var isPlainObject = (payload) => {
    if (typeof payload !== "object" || payload === null)
      return false;
    if (payload === Object.prototype)
      return false;
    if (Object.getPrototypeOf(payload) === null)
      return true;
    return Object.getPrototypeOf(payload) === Object.prototype;
  };
  var isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
  var isArray = (payload) => Array.isArray(payload);
  var isString = (payload) => typeof payload === "string";
  var isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
  var isBoolean2 = (payload) => typeof payload === "boolean";
  var isRegExp = (payload) => payload instanceof RegExp;
  var isMap = (payload) => payload instanceof Map;
  var isSet = (payload) => payload instanceof Set;
  var isSymbol = (payload) => getType(payload) === "Symbol";
  var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
  var isError = (payload) => payload instanceof Error;
  var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
  var isPrimitive = (payload) => isBoolean2(payload) || isNull2(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
  var isBigint = (payload) => typeof payload === "bigint";
  var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
  var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
  var isURL = (payload) => payload instanceof URL;

  // node_modules/superjson/dist/pathstringifier.js
  var escapeKey = (key) => key.replace(/\./g, "\\.");
  var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
  var parsePath = (string) => {
    const result = [];
    let segment = "";
    for (let i6 = 0; i6 < string.length; i6++) {
      let char = string.charAt(i6);
      const isEscapedDot = char === "\\" && string.charAt(i6 + 1) === ".";
      if (isEscapedDot) {
        segment += ".";
        i6++;
        continue;
      }
      const isEndOfSegment = char === ".";
      if (isEndOfSegment) {
        result.push(segment);
        segment = "";
        continue;
      }
      segment += char;
    }
    const lastSegment = segment;
    result.push(lastSegment);
    return result;
  };

  // node_modules/superjson/dist/transformer.js
  function simpleTransformation(isApplicable, annotation, transform, untransform) {
    return {
      isApplicable,
      annotation,
      transform,
      untransform
    };
  }
  var simpleRules = [
    simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
    simpleTransformation(isBigint, "bigint", (v2) => v2.toString(), (v2) => {
      if (typeof BigInt !== "undefined") {
        return BigInt(v2);
      }
      console.error("Please add a BigInt polyfill.");
      return v2;
    }),
    simpleTransformation(isDate, "Date", (v2) => v2.toISOString(), (v2) => new Date(v2)),
    simpleTransformation(isError, "Error", (v2, superJson) => {
      const baseError = {
        name: v2.name,
        message: v2.message
      };
      superJson.allowedErrorProps.forEach((prop) => {
        baseError[prop] = v2[prop];
      });
      return baseError;
    }, (v2, superJson) => {
      const e8 = new Error(v2.message);
      e8.name = v2.name;
      e8.stack = v2.stack;
      superJson.allowedErrorProps.forEach((prop) => {
        e8[prop] = v2[prop];
      });
      return e8;
    }),
    simpleTransformation(isRegExp, "regexp", (v2) => "" + v2, (regex) => {
      const body = regex.slice(1, regex.lastIndexOf("/"));
      const flags = regex.slice(regex.lastIndexOf("/") + 1);
      return new RegExp(body, flags);
    }),
    simpleTransformation(
      isSet,
      "set",
      // (sets only exist in es6+)
      // eslint-disable-next-line es5/no-es6-methods
      (v2) => [...v2.values()],
      (v2) => new Set(v2)
    ),
    simpleTransformation(isMap, "map", (v2) => [...v2.entries()], (v2) => new Map(v2)),
    simpleTransformation((v2) => isNaNValue(v2) || isInfinite(v2), "number", (v2) => {
      if (isNaNValue(v2)) {
        return "NaN";
      }
      if (v2 > 0) {
        return "Infinity";
      } else {
        return "-Infinity";
      }
    }, Number),
    simpleTransformation((v2) => v2 === 0 && 1 / v2 === -Infinity, "number", () => {
      return "-0";
    }, Number),
    simpleTransformation(isURL, "URL", (v2) => v2.toString(), (v2) => new URL(v2))
  ];
  function compositeTransformation(isApplicable, annotation, transform, untransform) {
    return {
      isApplicable,
      annotation,
      transform,
      untransform
    };
  }
  var symbolRule = compositeTransformation((s5, superJson) => {
    if (isSymbol(s5)) {
      const isRegistered = !!superJson.symbolRegistry.getIdentifier(s5);
      return isRegistered;
    }
    return false;
  }, (s5, superJson) => {
    const identifier = superJson.symbolRegistry.getIdentifier(s5);
    return ["symbol", identifier];
  }, (v2) => v2.description, (_2, a3, superJson) => {
    const value = superJson.symbolRegistry.getValue(a3[1]);
    if (!value) {
      throw new Error("Trying to deserialize unknown symbol");
    }
    return value;
  });
  var constructorToName = [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    Uint8ClampedArray
  ].reduce((obj, ctor) => {
    obj[ctor.name] = ctor;
    return obj;
  }, {});
  var typedArrayRule = compositeTransformation(isTypedArray, (v2) => ["typed-array", v2.constructor.name], (v2) => [...v2], (v2, a3) => {
    const ctor = constructorToName[a3[1]];
    if (!ctor) {
      throw new Error("Trying to deserialize unknown typed array");
    }
    return new ctor(v2);
  });
  function isInstanceOfRegisteredClass(potentialClass, superJson) {
    if (potentialClass?.constructor) {
      const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
      return isRegistered;
    }
    return false;
  }
  var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
    return ["class", identifier];
  }, (clazz, superJson) => {
    const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
    if (!allowedProps) {
      return { ...clazz };
    }
    const result = {};
    allowedProps.forEach((prop) => {
      result[prop] = clazz[prop];
    });
    return result;
  }, (v2, a3, superJson) => {
    const clazz = superJson.classRegistry.getValue(a3[1]);
    if (!clazz) {
      throw new Error(`Trying to deserialize unknown class '${a3[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
    }
    return Object.assign(Object.create(clazz.prototype), v2);
  });
  var customRule = compositeTransformation((value, superJson) => {
    return !!superJson.customTransformerRegistry.findApplicable(value);
  }, (value, superJson) => {
    const transformer = superJson.customTransformerRegistry.findApplicable(value);
    return ["custom", transformer.name];
  }, (value, superJson) => {
    const transformer = superJson.customTransformerRegistry.findApplicable(value);
    return transformer.serialize(value);
  }, (v2, a3, superJson) => {
    const transformer = superJson.customTransformerRegistry.findByName(a3[1]);
    if (!transformer) {
      throw new Error("Trying to deserialize unknown custom value");
    }
    return transformer.deserialize(v2);
  });
  var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
  var transformValue = (value, superJson) => {
    const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
    if (applicableCompositeRule) {
      return {
        value: applicableCompositeRule.transform(value, superJson),
        type: applicableCompositeRule.annotation(value, superJson)
      };
    }
    const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
    if (applicableSimpleRule) {
      return {
        value: applicableSimpleRule.transform(value, superJson),
        type: applicableSimpleRule.annotation
      };
    }
    return void 0;
  };
  var simpleRulesByAnnotation = {};
  simpleRules.forEach((rule) => {
    simpleRulesByAnnotation[rule.annotation] = rule;
  });
  var untransformValue = (json2, type2, superJson) => {
    if (isArray(type2)) {
      switch (type2[0]) {
        case "symbol":
          return symbolRule.untransform(json2, type2, superJson);
        case "class":
          return classRule.untransform(json2, type2, superJson);
        case "custom":
          return customRule.untransform(json2, type2, superJson);
        case "typed-array":
          return typedArrayRule.untransform(json2, type2, superJson);
        default:
          throw new Error("Unknown transformation: " + type2);
      }
    } else {
      const transformation = simpleRulesByAnnotation[type2];
      if (!transformation) {
        throw new Error("Unknown transformation: " + type2);
      }
      return transformation.untransform(json2, superJson);
    }
  };

  // node_modules/superjson/dist/accessDeep.js
  var getNthKey = (value, n8) => {
    if (n8 > value.size)
      throw new Error("index out of bounds");
    const keys = value.keys();
    while (n8 > 0) {
      keys.next();
      n8--;
    }
    return keys.next().value;
  };
  function validatePath(path) {
    if (includes(path, "__proto__")) {
      throw new Error("__proto__ is not allowed as a property");
    }
    if (includes(path, "prototype")) {
      throw new Error("prototype is not allowed as a property");
    }
    if (includes(path, "constructor")) {
      throw new Error("constructor is not allowed as a property");
    }
  }
  var getDeep = (object, path) => {
    validatePath(path);
    for (let i6 = 0; i6 < path.length; i6++) {
      const key = path[i6];
      if (isSet(object)) {
        object = getNthKey(object, +key);
      } else if (isMap(object)) {
        const row = +key;
        const type2 = +path[++i6] === 0 ? "key" : "value";
        const keyOfRow = getNthKey(object, row);
        switch (type2) {
          case "key":
            object = keyOfRow;
            break;
          case "value":
            object = object.get(keyOfRow);
            break;
        }
      } else {
        object = object[key];
      }
    }
    return object;
  };
  var setDeep = (object, path, mapper) => {
    validatePath(path);
    if (path.length === 0) {
      return mapper(object);
    }
    let parent = object;
    for (let i6 = 0; i6 < path.length - 1; i6++) {
      const key = path[i6];
      if (isArray(parent)) {
        const index = +key;
        parent = parent[index];
      } else if (isPlainObject(parent)) {
        parent = parent[key];
      } else if (isSet(parent)) {
        const row = +key;
        parent = getNthKey(parent, row);
      } else if (isMap(parent)) {
        const isEnd = i6 === path.length - 2;
        if (isEnd) {
          break;
        }
        const row = +key;
        const type2 = +path[++i6] === 0 ? "key" : "value";
        const keyOfRow = getNthKey(parent, row);
        switch (type2) {
          case "key":
            parent = keyOfRow;
            break;
          case "value":
            parent = parent.get(keyOfRow);
            break;
        }
      }
    }
    const lastKey = path[path.length - 1];
    if (isArray(parent)) {
      parent[+lastKey] = mapper(parent[+lastKey]);
    } else if (isPlainObject(parent)) {
      parent[lastKey] = mapper(parent[lastKey]);
    }
    if (isSet(parent)) {
      const oldValue = getNthKey(parent, +lastKey);
      const newValue = mapper(oldValue);
      if (oldValue !== newValue) {
        parent.delete(oldValue);
        parent.add(newValue);
      }
    }
    if (isMap(parent)) {
      const row = +path[path.length - 2];
      const keyToRow = getNthKey(parent, row);
      const type2 = +lastKey === 0 ? "key" : "value";
      switch (type2) {
        case "key": {
          const newKey = mapper(keyToRow);
          parent.set(newKey, parent.get(keyToRow));
          if (newKey !== keyToRow) {
            parent.delete(keyToRow);
          }
          break;
        }
        case "value": {
          parent.set(keyToRow, mapper(parent.get(keyToRow)));
          break;
        }
      }
    }
    return object;
  };

  // node_modules/superjson/dist/plainer.js
  function traverse(tree, walker2, origin = []) {
    if (!tree) {
      return;
    }
    if (!isArray(tree)) {
      forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
      return;
    }
    const [nodeValue, children] = tree;
    if (children) {
      forEach(children, (child, key) => {
        traverse(child, walker2, [...origin, ...parsePath(key)]);
      });
    }
    walker2(nodeValue, origin);
  }
  function applyValueAnnotations(plain, annotations, superJson) {
    traverse(annotations, (type2, path) => {
      plain = setDeep(plain, path, (v2) => untransformValue(v2, type2, superJson));
    });
    return plain;
  }
  function applyReferentialEqualityAnnotations(plain, annotations) {
    function apply(identicalPaths, path) {
      const object = getDeep(plain, parsePath(path));
      identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
        plain = setDeep(plain, identicalObjectPath, () => object);
      });
    }
    if (isArray(annotations)) {
      const [root, other] = annotations;
      root.forEach((identicalPath) => {
        plain = setDeep(plain, parsePath(identicalPath), () => plain);
      });
      if (other) {
        forEach(other, apply);
      }
    } else {
      forEach(annotations, apply);
    }
    return plain;
  }
  var isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
  function addIdentity(object, path, identities) {
    const existingSet = identities.get(object);
    if (existingSet) {
      existingSet.push(path);
    } else {
      identities.set(object, [path]);
    }
  }
  function generateReferentialEqualityAnnotations(identitites, dedupe) {
    const result = {};
    let rootEqualityPaths = void 0;
    identitites.forEach((paths) => {
      if (paths.length <= 1) {
        return;
      }
      if (!dedupe) {
        paths = paths.map((path) => path.map(String)).sort((a3, b3) => a3.length - b3.length);
      }
      const [representativePath, ...identicalPaths] = paths;
      if (representativePath.length === 0) {
        rootEqualityPaths = identicalPaths.map(stringifyPath);
      } else {
        result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
      }
    });
    if (rootEqualityPaths) {
      if (isEmptyObject(result)) {
        return [rootEqualityPaths];
      } else {
        return [rootEqualityPaths, result];
      }
    } else {
      return isEmptyObject(result) ? void 0 : result;
    }
  }
  var walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
    const primitive = isPrimitive(object);
    if (!primitive) {
      addIdentity(object, path, identities);
      const seen = seenObjects.get(object);
      if (seen) {
        return dedupe ? {
          transformedValue: null
        } : seen;
      }
    }
    if (!isDeep(object, superJson)) {
      const transformed2 = transformValue(object, superJson);
      const result2 = transformed2 ? {
        transformedValue: transformed2.value,
        annotations: [transformed2.type]
      } : {
        transformedValue: object
      };
      if (!primitive) {
        seenObjects.set(object, result2);
      }
      return result2;
    }
    if (includes(objectsInThisPath, object)) {
      return {
        transformedValue: null
      };
    }
    const transformationResult = transformValue(object, superJson);
    const transformed = transformationResult?.value ?? object;
    const transformedValue = isArray(transformed) ? [] : {};
    const innerAnnotations = {};
    forEach(transformed, (value, index) => {
      if (index === "__proto__" || index === "constructor" || index === "prototype") {
        throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
      }
      const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
      transformedValue[index] = recursiveResult.transformedValue;
      if (isArray(recursiveResult.annotations)) {
        innerAnnotations[index] = recursiveResult.annotations;
      } else if (isPlainObject(recursiveResult.annotations)) {
        forEach(recursiveResult.annotations, (tree, key) => {
          innerAnnotations[escapeKey(index) + "." + key] = tree;
        });
      }
    });
    const result = isEmptyObject(innerAnnotations) ? {
      transformedValue,
      annotations: !!transformationResult ? [transformationResult.type] : void 0
    } : {
      transformedValue,
      annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
    };
    if (!primitive) {
      seenObjects.set(object, result);
    }
    return result;
  };

  // node_modules/is-what/dist/index.js
  function getType2(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
  }
  function isArray2(payload) {
    return getType2(payload) === "Array";
  }
  function isPlainObject2(payload) {
    if (getType2(payload) !== "Object")
      return false;
    const prototype = Object.getPrototypeOf(payload);
    return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
  }
  function isNull3(payload) {
    return getType2(payload) === "Null";
  }
  function isOneOf(a3, b3, c5, d3, e8) {
    return (value) => a3(value) || b3(value) || !!c5 && c5(value) || !!d3 && d3(value) || !!e8 && e8(value);
  }
  function isUndefined2(payload) {
    return getType2(payload) === "Undefined";
  }
  var isNullOrUndefined = isOneOf(isNull3, isUndefined2);

  // node_modules/copy-anything/dist/index.js
  function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
    const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
    if (propType === "enumerable")
      carry[key] = newVal;
    if (includeNonenumerable && propType === "nonenumerable") {
      Object.defineProperty(carry, key, {
        value: newVal,
        enumerable: false,
        writable: true,
        configurable: true
      });
    }
  }
  function copy(target, options = {}) {
    if (isArray2(target)) {
      return target.map((item) => copy(item, options));
    }
    if (!isPlainObject2(target)) {
      return target;
    }
    const props = Object.getOwnPropertyNames(target);
    const symbols = Object.getOwnPropertySymbols(target);
    return [...props, ...symbols].reduce((carry, key) => {
      if (isArray2(options.props) && !options.props.includes(key)) {
        return carry;
      }
      const val = target[key];
      const newVal = copy(val, options);
      assignProp(carry, key, newVal, target, options.nonenumerable);
      return carry;
    }, {});
  }

  // node_modules/superjson/dist/index.js
  var SuperJSON = class {
    /**
     * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
     */
    constructor({ dedupe = false } = {}) {
      this.classRegistry = new ClassRegistry();
      this.symbolRegistry = new Registry((s5) => s5.description ?? "");
      this.customTransformerRegistry = new CustomTransformerRegistry();
      this.allowedErrorProps = [];
      this.dedupe = dedupe;
    }
    serialize(object) {
      const identities = /* @__PURE__ */ new Map();
      const output = walker(object, identities, this, this.dedupe);
      const res = {
        json: output.transformedValue
      };
      if (output.annotations) {
        res.meta = {
          ...res.meta,
          values: output.annotations
        };
      }
      const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
      if (equalityAnnotations) {
        res.meta = {
          ...res.meta,
          referentialEqualities: equalityAnnotations
        };
      }
      return res;
    }
    deserialize(payload) {
      const { json: json2, meta } = payload;
      let result = copy(json2);
      if (meta?.values) {
        result = applyValueAnnotations(result, meta.values, this);
      }
      if (meta?.referentialEqualities) {
        result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
      }
      return result;
    }
    stringify(object) {
      return JSON.stringify(this.serialize(object));
    }
    parse(string) {
      return this.deserialize(JSON.parse(string));
    }
    registerClass(v2, options) {
      this.classRegistry.register(v2, options);
    }
    registerSymbol(v2, identifier) {
      this.symbolRegistry.register(v2, identifier);
    }
    registerCustom(transformer, name) {
      this.customTransformerRegistry.register({
        name,
        ...transformer
      });
    }
    allowErrorProps(...props) {
      this.allowedErrorProps.push(...props);
    }
  };
  SuperJSON.defaultInstance = new SuperJSON();
  SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
  SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
  SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
  SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
  SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
  SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
  SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
  SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
  var serialize = SuperJSON.serialize;
  var deserialize = SuperJSON.deserialize;
  var stringify = SuperJSON.stringify;
  var parse = SuperJSON.parse;
  var registerClass = SuperJSON.registerClass;
  var registerCustom = SuperJSON.registerCustom;
  var registerSymbol = SuperJSON.registerSymbol;
  var allowErrorProps = SuperJSON.allowErrorProps;

  // src/inspector/console.ts
  var globalConsoleErrors = [];
  var globalConsoleWarnings = [];
  var globalConsoleInfo = [];
  var MAX_CONSOLE_MESSAGES = 50;
  var consoleErrorCaptureInitialized = false;
  var overridableFunctionNames = ["error", "warn", "info", "log", "assert"];
  function addErrorToGlobalList(error) {
    globalConsoleErrors.push(error);
    if (globalConsoleErrors.length > MAX_CONSOLE_MESSAGES) {
      globalConsoleErrors.shift();
    }
  }
  function addWarningToGlobalList(warning) {
    globalConsoleWarnings.push(warning);
    if (globalConsoleWarnings.length > MAX_CONSOLE_MESSAGES) {
      globalConsoleWarnings.shift();
    }
  }
  function addInfoToGlobalList(info) {
    globalConsoleInfo.push(info);
    if (globalConsoleInfo.length > MAX_CONSOLE_MESSAGES) {
      globalConsoleInfo.shift();
    }
  }
  function serializeArgument(arg) {
    if (typeof arg === "object") {
      if (arg instanceof Error) {
        return JSON.stringify(arg, Object.getOwnPropertyNames(arg));
      }
      try {
        return JSON.stringify(arg, null, 2);
      } catch {
        return String(arg);
      }
    } else {
      return String(arg);
    }
  }
  function saveConsoleLog(functionName, args) {
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
    const serializedArgs = args.map(serializeArgument).join("\n");
    const logEntry = `[${functionName.toUpperCase()}] ${timestamp2}
Message: ${serializedArgs}
---`;
    switch (functionName) {
      case "error":
      case "assert":
        addErrorToGlobalList(logEntry);
        break;
      case "warn":
        addWarningToGlobalList(logEntry);
        break;
      case "info":
      case "log":
        addInfoToGlobalList(logEntry);
        break;
    }
  }
  function createConsoleProxy(originalFunction, functionName) {
    const proxyHandler = {
      apply: (target, thisArgument, argumentsList) => {
        if (functionName === "assert" && argumentsList[0]) {
          return target.apply(thisArgument, argumentsList);
        }
        saveConsoleLog(functionName, argumentsList);
        return target.apply(thisArgument, argumentsList);
      }
    };
    return new Proxy(originalFunction, proxyHandler);
  }
  function setConsoleProxies() {
    if (!console.original) {
      console.original = {};
    }
    overridableFunctionNames.forEach((funcName) => {
      if (!console.original[funcName]) {
        console.original[funcName] = console[funcName];
      }
      console[funcName] = createConsoleProxy(console[funcName], funcName);
    });
  }
  function initializeConsoleErrorCapture() {
    if (consoleErrorCaptureInitialized) return;
    setConsoleProxies();
    window.addEventListener("error", (event) => {
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
      const errorDetails = event.error ? serializeArgument(event.error) : `${event.message}`;
      addErrorToGlobalList(`[UNCAUGHT ERROR] ${timestamp2}
Message: ${errorDetails}
File: ${event.filename}:${event.lineno}:${event.colno}
Stack: ${event.error?.stack || "No stack trace available"}
---`);
    });
    window.addEventListener("unhandledrejection", (event) => {
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
      const reason = serializeArgument(event.reason);
      addErrorToGlobalList(`[UNHANDLED PROMISE REJECTION] ${timestamp2}
Reason: ${reason}
---`);
    });
    window.addEventListener("error", (event) => {
      if (event.target !== window && event.target) {
        const target = event.target;
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const tagName = target.tagName?.toLowerCase();
        const src = target.src || target.href;
        addErrorToGlobalList(`[RESOURCE ERROR] ${timestamp2}
Failed to load ${tagName}: ${src}
Element: ${target.outerHTML?.substring(0, 200)}...
---`);
      }
    }, true);
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch.apply(window, args);
        if (!response.ok) {
          const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
          const url = typeof args[0] === "string" ? args[0] : args[0] instanceof Request ? args[0].url : args[0] instanceof URL ? args[0].href : String(args[0]);
          addErrorToGlobalList(`[NETWORK ERROR] ${timestamp2}
Failed request: ${response.status} ${response.statusText}
URL: ${url}
---`);
        }
        return response;
      } catch (error) {
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const url = typeof args[0] === "string" ? args[0] : args[0] instanceof Request ? args[0].url : args[0] instanceof URL ? args[0].href : String(args[0]);
        addErrorToGlobalList(`[FETCH ERROR] ${timestamp2}
Request failed: ${serializeArgument(error)}
URL: ${url}
---`);
        throw error;
      }
    };
    consoleErrorCaptureInitialized = true;
    console.log("\u{1F50D} Console error capture initialized successfully");
  }
  function captureConsoleErrors() {
    const captured = [...globalConsoleErrors];
    return captured;
  }
  function captureConsoleWarnings() {
    const captured = [...globalConsoleWarnings];
    return captured;
  }
  function captureConsoleInfo() {
    const captured = [...globalConsoleInfo];
    return captured;
  }

  // src/inspector/logger.ts
  function createLogger(verbose) {
    return {
      log: verbose ? console.log.bind(console) : () => {
      },
      info: verbose ? console.info.bind(console) : () => {
      },
      warn: verbose ? console.warn.bind(console) : () => {
      },
      error: verbose ? console.error.bind(console) : () => {
      }
    };
  }

  // src/inspector/ai.ts
  function createAIManager(verbose = false) {
    const logger = createLogger(verbose);
    let trpcClient = null;
    let wsClient = null;
    let currentSubscription = null;
    let globalSessionId = null;
    const clientId = Math.random().toString(36).substring(7);
    initializeConsoleErrorCapture();
    return {
      initialize(aiEndpoint) {
        if (!aiEndpoint) return;
        if (wsClient) {
          wsClient.close();
        }
        const wsUrl = aiEndpoint.replace("http://", "ws://").replace("https://", "wss://");
        wsClient = createWSClient({
          url: `${wsUrl}/trpc`
        });
        trpcClient = createTRPCClient({
          links: [
            splitLink({
              condition(op) {
                return op.type === "subscription";
              },
              true: wsLink({
                client: wsClient,
                transformer: SuperJSON
              }),
              false: httpBatchLink({
                url: `${aiEndpoint}/trpc`,
                transformer: SuperJSON
              })
            })
          ]
        });
      },
      async sendMessage(userPrompt, selectedElements, pageInfo, cwd, handler) {
        if (!trpcClient) {
          throw new Error("tRPC client not initialized");
        }
        if (currentSubscription) {
          logger.log(`\u{1F7E1} [CLIENT ${clientId}] Cancelling existing subscription before creating new one`);
          currentSubscription.unsubscribe();
          currentSubscription = null;
        }
        logger.log(`\u{1F7E2} [CLIENT ${clientId}] Creating new subscription for prompt: "${userPrompt.substring(0, 30)}..."`);
        let consoleErrors;
        let consoleWarnings;
        let consoleInfo;
        if (userPrompt.includes("@error")) {
          consoleErrors = captureConsoleErrors();
        }
        if (userPrompt.includes("@warning")) {
          consoleWarnings = captureConsoleWarnings();
        }
        if (userPrompt.includes("@info")) {
          consoleInfo = captureConsoleInfo();
        }
        const structuredInput = {
          userPrompt,
          selectedElements,
          pageInfo,
          cwd,
          sessionId: globalSessionId || void 0,
          consoleErrors,
          consoleWarnings,
          consoleInfo
        };
        logger.log("structuredInput", structuredInput);
        const subscription = trpcClient.sendMessage.subscribe(
          structuredInput,
          {
            onData: (data) => {
              logger.log(`\u{1F4E5} [CLIENT ${clientId}] SSE data received:`, data);
              if ("session_id" in data && data.session_id) {
                globalSessionId = data.session_id;
              }
              handler.onData(data);
              if (data.type === "result") {
                logger.log(`\u2705 [CLIENT ${clientId}] AI request completed with session ID:`, data.session_id);
                currentSubscription = null;
                handler.onComplete();
              }
            },
            onError: (error) => {
              logger.error(`\u274C [CLIENT ${clientId}] Subscription error:`, error);
              currentSubscription = null;
              handler.onError(error);
            }
          }
        );
        currentSubscription = subscription;
      },
      async newChat() {
        if (trpcClient) {
          try {
            await trpcClient.newChat.mutate();
            globalSessionId = null;
          } catch (error) {
            logger.error("Failed to start new chat:", error);
            throw error;
          }
        } else {
          logger.warn("tRPC client not initialized");
          throw new Error("tRPC client not initialized");
        }
      },
      cancel() {
        if (currentSubscription) {
          logger.log("Cancelling current AI request");
          currentSubscription.unsubscribe();
          currentSubscription = null;
        }
      },
      getSessionId() {
        return globalSessionId;
      },
      isInitialized() {
        return trpcClient !== null;
      },
      isProcessing() {
        return currentSubscription !== null;
      },
      destroy() {
        if (currentSubscription) {
          currentSubscription.unsubscribe();
        }
        if (wsClient) {
          wsClient.close();
        }
      }
    };
  }

  // src/utils/xpath.ts
  var XPathUtils = class {
    static generateXPath(element) {
      if (!element) return "";
      if (element === document.body) return "//body";
      if (element === document.documentElement) return "/html";
      const steps = [];
      let contextNode = element;
      while (contextNode) {
        const step = this.getXPathStep(contextNode, contextNode === element);
        if (!step.value) break;
        steps.push(step.value);
        if (step.optimized) break;
        const parent = contextNode.parentNode;
        if (!parent || parent.nodeType === Node.DOCUMENT_NODE) break;
        contextNode = parent;
      }
      steps.reverse();
      return (steps.length && steps[0].includes("@id") ? "" : "/") + steps.join("/");
    }
    static getXPathStep(node, isTargetNode) {
      if (node.nodeType !== Node.ELEMENT_NODE) {
        return { value: "", optimized: false };
      }
      const id = node.getAttribute("id");
      if (id && this.isValidId(id)) {
        if (document.querySelectorAll(`#${CSS.escape(id)}`).length === 1) {
          return {
            value: `//*[@id="${id}"]`,
            optimized: true
          };
        }
      }
      const nodeName = node.nodeName.toLowerCase();
      if (nodeName === "body" || nodeName === "head" || nodeName === "html") {
        return {
          value: nodeName,
          optimized: true
        };
      }
      const ownIndex = this.getXPathIndex(node);
      if (ownIndex === -1) {
        return { value: "", optimized: false };
      }
      let ownValue = nodeName;
      if (isTargetNode && nodeName === "input" && node.getAttribute("type") && !id && !node.getAttribute("class")) {
        ownValue += `[@type="${node.getAttribute("type")}"]`;
      }
      if (ownIndex > 0) {
        ownValue += `[${ownIndex + 1}]`;
      }
      return {
        value: ownValue,
        optimized: false
      };
    }
    static getXPathIndex(node) {
      const siblings = node.parentNode?.children;
      if (!siblings) return 0;
      const areNodesSimilar = (left, right) => {
        if (left === right) return true;
        return left.nodeName.toLowerCase() === right.nodeName.toLowerCase();
      };
      let hasSameNamedElements = false;
      for (let i6 = 0; i6 < siblings.length; ++i6) {
        if (areNodesSimilar(node, siblings[i6]) && siblings[i6] !== node) {
          hasSameNamedElements = true;
          break;
        }
      }
      if (!hasSameNamedElements) return 0;
      let ownIndex = 0;
      for (let i6 = 0; i6 < siblings.length; ++i6) {
        if (areNodesSimilar(node, siblings[i6])) {
          if (siblings[i6] === node) {
            return ownIndex;
          }
          ++ownIndex;
        }
      }
      return -1;
    }
    static isValidId(id) {
      return Boolean(id) && /^\S.*$/.test(id) && !/[[\](){}<>]/.test(id);
    }
    /**
     * Generate optimized CSS selector using optimal-select library
     */
    static generateOptimalSelector(element) {
      return this.generateEnhancedCSSSelector(element);
    }
    /**
     * Generate enhanced CSS selector optimized for browser environment
     */
    static generateEnhancedCSSSelector(element) {
      const parts = [];
      let currentElement = element;
      while (currentElement && currentElement !== document.body) {
        let selector = currentElement.tagName.toLowerCase();
        if (currentElement.id && this.isUniqueId(currentElement.id)) {
          selector += `#${currentElement.id}`;
          parts.unshift(selector);
          break;
        }
        if (currentElement.className && typeof currentElement.className === "string") {
          const classes = currentElement.className.split(" ").filter((c5) => c5 && !c5.includes("css-") && !c5.includes("emotion-")).slice(0, 2);
          if (classes.length > 0) {
            selector += "." + classes.join(".");
          }
        }
        const siblings = Array.from(currentElement.parentElement?.children || []).filter((sibling) => sibling.tagName === currentElement.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(currentElement) + 1;
          selector += `:nth-child(${index})`;
        }
        parts.unshift(selector);
        currentElement = currentElement.parentElement;
      }
      return parts.join(" > ");
    }
    /**
     * Validate XPath by testing if it uniquely identifies the element
     */
    static validateXPath(xpath, targetElement) {
      try {
        const result = document.evaluate(
          xpath,
          document,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        );
        return result.singleNodeValue === targetElement;
      } catch (error) {
        console.warn("XPath validation failed:", error);
        return false;
      }
    }
    /**
     * Validate CSS selector by testing if it uniquely identifies the element
     */
    static validateCSSSelector(selector, targetElement) {
      try {
        const elements = document.querySelectorAll(selector);
        return elements.length === 1 && elements[0] === targetElement;
      } catch (error) {
        console.warn("CSS selector validation failed:", error);
        return false;
      }
    }
    /**
     * Find element using XPath
     */
    static findElementByXPath(xpath) {
      try {
        const result = document.evaluate(
          xpath,
          document,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        );
        return result.singleNodeValue;
      } catch (error) {
        console.warn("Failed to find element by XPath:", error);
        return null;
      }
    }
    /**
     * Generate comprehensive selector information for an element
     */
    static generateElementSelector(element) {
      const xpath = this.generateXPath(element);
      const cssSelector = this.generateOptimalSelector(element);
      const siblings = Array.from(element.parentElement?.children || []).filter((sibling) => sibling.tagName === element.tagName);
      const position = siblings.length > 1 ? {
        index: siblings.indexOf(element) + 1,
        total: siblings.length
      } : void 0;
      const selector = {
        xpath,
        cssSelector,
        position
      };
      if (element.id && this.isUniqueId(element.id)) {
        selector.uniqueId = element.id;
      }
      return selector;
    }
    /**
     * Check if an ID is unique in the document
     */
    static isUniqueId(id) {
      try {
        return document.querySelectorAll(`#${CSS.escape(id)}`).length === 1;
      } catch (error) {
        return false;
      }
    }
    /**
     * Generate multiple selector strategies for robust element identification
     */
    static generateRobustSelectors(element) {
      const primary = this.generateElementSelector(element);
      const fallbacks = [];
      if (element.id && this.isUniqueId(element.id)) {
        fallbacks.push(`#${element.id}`);
      }
      if (element.getAttribute("data-testid")) {
        fallbacks.push(`[data-testid="${element.getAttribute("data-testid")}"]`);
      }
      if (element.getAttribute("aria-label")) {
        fallbacks.push(`[aria-label="${element.getAttribute("aria-label")}"]`);
      }
      const textContent = element.textContent?.trim();
      if (textContent && textContent.length > 0 && textContent.length < 50) {
        const elementsWithSameText = Array.from(document.querySelectorAll("*")).filter((el) => el.textContent?.trim() === textContent);
        if (elementsWithSameText.length === 1) {
          fallbacks.push(`${element.tagName.toLowerCase()}:contains("${textContent}")`);
        }
      }
      let confidence = "low";
      if (this.validateXPath(primary.xpath, element) && this.validateCSSSelector(primary.cssSelector, element)) {
        confidence = "high";
      } else if (fallbacks.length > 0) {
        confidence = "medium";
      }
      return {
        primary,
        fallbacks,
        confidence
      };
    }
  };

  // src/inspector/selection.ts
  function createElementSelectionManager() {
    const selectedElements = /* @__PURE__ */ new Map();
    const badges = /* @__PURE__ */ new Map();
    let colorIndex = 0;
    const colors = [
      "#FF6B6B",
      "#FF9671",
      "#FFA75F",
      "#F9D423",
      "#FECA57",
      "#FF9FF3",
      "#FF7E67",
      "#FF8C42",
      "#FFC857",
      "#FFA26B"
    ];
    function createBadge(index, color, element, componentFinder) {
      const badge = document.createElement("div");
      badge.classList.add("inspector-badge");
      const shadow = badge.attachShadow({ mode: "open" });
      const style = document.createElement("style");
      style.textContent = `
      .badge {
        height: 20px;
        padding: 0 5px;
        background-color: ${color};
        color: white;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        pointer-events: none;
      }
    `;
      const badgeContent = document.createElement("div");
      badgeContent.classList.add("badge", "inspector-ignore");
      const component = componentFinder?.(element);
      if (component && component.componentLocation) {
        const componentPath = component.componentLocation.split("@")[0];
        const fileName = componentPath.split("/").pop();
        badgeContent.textContent = `(${index}) [${fileName}]`;
      } else {
        badgeContent.textContent = `(${index}) ${element.tagName}`;
      }
      shadow.appendChild(style);
      shadow.appendChild(badgeContent);
      const topMargin = -15;
      const leftMargin = 7;
      const rect = element.getBoundingClientRect();
      badge.style.position = "fixed";
      badge.style.top = `${rect.top + topMargin}px`;
      badge.style.left = `${rect.left + leftMargin}px`;
      badge.style.zIndex = "999998";
      document.body.appendChild(badge);
      const updatePosition = () => {
        const rect2 = element.getBoundingClientRect();
        badge.style.top = `${rect2.top + topMargin}px`;
        badge.style.left = `${rect2.left + leftMargin}px`;
      };
      window.addEventListener("scroll", updatePosition, true);
      window.addEventListener("resize", updatePosition);
      badge._cleanup = () => {
        window.removeEventListener("scroll", updatePosition, true);
        window.removeEventListener("resize", updatePosition);
      };
      return badge;
    }
    function reindexElements() {
      let index = 1;
      selectedElements.forEach((data, element) => {
        data.index = index;
        const badge = badges.get(element);
        if (badge) {
          const badgeContent = badge.shadowRoot?.querySelector(".badge");
          if (badgeContent) {
            badgeContent.textContent = `(${index}) ${element.tagName}`;
          }
        }
        index++;
      });
    }
    function findSelectedParent(element) {
      let currentElement = element.parentElement;
      while (currentElement && currentElement !== document.body) {
        if (selectedElements.has(currentElement)) {
          return currentElement;
        }
        currentElement = currentElement.parentElement;
      }
      return null;
    }
    function findSelectedChildren(element) {
      const children = [];
      selectedElements.forEach((_2, selectedElement) => {
        if (element.contains(selectedElement) && selectedElement !== element) {
          children.push(selectedElement);
        }
      });
      return children;
    }
    return {
      selectElement(element, componentFinder) {
        const color = colors[colorIndex % colors.length];
        const index = selectedElements.size + 1;
        colorIndex++;
        element.style.outline = `3px solid ${color}`;
        element.style.outlineOffset = "-1px";
        const badge = createBadge(index, color, element, componentFinder);
        badges.set(element, badge);
        selectedElements.set(element, {
          color,
          originalOutline: element.style.outline,
          originalOutlineOffset: element.style.outlineOffset,
          index
        });
      },
      deselectElement(element) {
        const elementData = selectedElements.get(element);
        if (elementData) {
          ;
          element.style.outline = "";
          element.style.outlineOffset = "";
          const badge = badges.get(element);
          if (badge) {
            badge.remove();
            badges.delete(element);
          }
          selectedElements.delete(element);
          reindexElements();
        }
      },
      clearAllSelections() {
        selectedElements.forEach((_2, element) => {
          ;
          element.style.outline = "";
          element.style.outlineOffset = "";
        });
        badges.forEach((badge) => badge.remove());
        badges.clear();
        selectedElements.clear();
        colorIndex = 0;
      },
      hasElement(element) {
        return selectedElements.has(element);
      },
      getSelectedElements() {
        return selectedElements;
      },
      getSelectedCount() {
        return selectedElements.size;
      },
      findSelectedParent,
      findSelectedChildren,
      buildHierarchicalStructure(componentFinder, imagePaths) {
        const rootElements = [];
        selectedElements.forEach((_2, element) => {
          if (!findSelectedParent(element)) {
            rootElements.push(element);
          }
        });
        const buildElementInfo = (element) => {
          const data = selectedElements.get(element);
          const children = findSelectedChildren(element);
          const componentData = componentFinder?.(element);
          const elementInfo = {
            index: data.index,
            tagName: element.tagName,
            xpath: XPathUtils.generateXPath(element),
            cssSelector: XPathUtils.generateEnhancedCSSSelector(element),
            textContent: element.textContent?.substring(0, 100) || "",
            attributes: Array.from(element.attributes).reduce((acc, attr) => {
              if (attr.name !== "style") {
                acc[attr.name] = attr.value;
              }
              return acc;
            }, {}),
            children: []
          };
          if (imagePaths && imagePaths.has(element)) {
            elementInfo.imagePath = imagePaths.get(element);
          }
          try {
            const htmlElement = element;
            const computedStyle = window.getComputedStyle(htmlElement);
            elementInfo.computedStyles = {
              width: htmlElement.offsetWidth,
              height: htmlElement.offsetHeight,
              fontSize: computedStyle.fontSize,
              fontFamily: computedStyle.fontFamily,
              color: computedStyle.color || void 0,
              backgroundColor: computedStyle.backgroundColor || void 0,
              display: computedStyle.display || void 0,
              position: computedStyle.position || void 0
            };
          } catch (error) {
            console.warn("Failed to get computed styles for element:", error);
          }
          if (componentData) {
            elementInfo.componentData = componentData;
          }
          const directChildren = children.filter(
            (child) => findSelectedParent(child) === element
          );
          directChildren.forEach((child) => {
            elementInfo.children.push(buildElementInfo(child));
          });
          return elementInfo;
        };
        return rootElements.map((element) => buildElementInfo(element));
      }
    };
  }

  // src/inspector/inspection.ts
  function createInspectionManager(onElementSelect, shouldIgnoreElement, isElementSelected) {
    let isInspecting = false;
    let currentHoveredElement = null;
    let inspectionStyleElement = null;
    function addInspectionStyles() {
      inspectionStyleElement = document.createElement("style");
      inspectionStyleElement.id = "inspector-toolbar-styles";
      inspectionStyleElement.textContent = `
      * {
        cursor: crosshair !important;
      }
    `;
      document.head.appendChild(inspectionStyleElement);
    }
    function removeInspectionStyles() {
      if (inspectionStyleElement) {
        inspectionStyleElement.remove();
        inspectionStyleElement = null;
      }
    }
    function removeHoverHighlight() {
      if (currentHoveredElement) {
        if (!isElementSelected?.(currentHoveredElement)) {
          ;
          currentHoveredElement.style.outline = "";
          currentHoveredElement.style.outlineOffset = "";
        }
        currentHoveredElement = null;
      }
    }
    function handleMouseOver(e8) {
      const target = e8.target;
      if (shouldIgnoreElement?.(target)) return;
      removeHoverHighlight();
      target.style.outline = "3px solid #3B82F6";
      target.style.outlineOffset = "-1px";
      currentHoveredElement = target;
    }
    function handleMouseOut(e8) {
      const target = e8.target;
      if (shouldIgnoreElement?.(target)) return;
      if (!isElementSelected?.(target)) {
        ;
        target.style.outline = "";
        target.style.outlineOffset = "";
      }
    }
    function handleElementClick(e8) {
      const target = e8.target;
      if (shouldIgnoreElement?.(target)) return;
      e8.preventDefault();
      e8.stopPropagation();
      e8.stopImmediatePropagation();
      onElementSelect?.(target);
    }
    function preventMouseEvents(e8) {
      const target = e8.target;
      if (shouldIgnoreElement?.(target)) return;
      e8.preventDefault();
      e8.stopPropagation();
      e8.stopImmediatePropagation();
    }
    return {
      enterInspectionMode() {
        if (isInspecting) return;
        isInspecting = true;
        addInspectionStyles();
        document.addEventListener("mouseover", handleMouseOver, true);
        document.addEventListener("mouseout", handleMouseOut, true);
        document.addEventListener("click", handleElementClick, true);
        document.addEventListener("mousedown", preventMouseEvents, true);
        document.addEventListener("mouseup", preventMouseEvents, true);
        document.addEventListener("dblclick", preventMouseEvents, true);
        document.addEventListener("contextmenu", preventMouseEvents, true);
      },
      exitInspectionMode() {
        if (!isInspecting) return;
        isInspecting = false;
        removeInspectionStyles();
        document.removeEventListener("mouseover", handleMouseOver, true);
        document.removeEventListener("mouseout", handleMouseOut, true);
        document.removeEventListener("click", handleElementClick, true);
        document.removeEventListener("mousedown", preventMouseEvents, true);
        document.removeEventListener("mouseup", preventMouseEvents, true);
        document.removeEventListener("dblclick", preventMouseEvents, true);
        document.removeEventListener("contextmenu", preventMouseEvents, true);
        removeHoverHighlight();
      },
      isInInspectionMode() {
        return isInspecting;
      },
      destroy() {
        if (isInspecting) {
          isInspecting = false;
          removeInspectionStyles();
          document.removeEventListener("mouseover", handleMouseOver, true);
          document.removeEventListener("mouseout", handleMouseOut, true);
          document.removeEventListener("click", handleElementClick, true);
          document.removeEventListener("mousedown", preventMouseEvents, true);
          document.removeEventListener("mouseup", preventMouseEvents, true);
          document.removeEventListener("dblclick", preventMouseEvents, true);
          document.removeEventListener("contextmenu", preventMouseEvents, true);
          removeHoverHighlight();
        }
      }
    };
  }

  // src/utils/sourcemap.ts
  var BasicSourceMapConsumer = class {
    constructor(sourceMap) {
      this.sources = sourceMap.sources || [];
      this.sourcesContent = sourceMap.sourcesContent;
    }
    /**
     * Find original position for generated position
     * This is a simplified implementation that looks for approximate mappings
     */
    originalPositionFor(line, column) {
      try {
        if (this.sources.length > 0) {
          return {
            line,
            column,
            source: this.sources[0],
            // Use first source as fallback
            name: void 0
          };
        }
        return null;
      } catch (error) {
        console.warn("Failed to parse source map:", error);
        return null;
      }
    }
    /**
     * Get source content for a given source file
     */
    sourceContentFor(source) {
      if (!this.sourcesContent) return null;
      const index = this.sources.indexOf(source);
      return index >= 0 ? this.sourcesContent[index] : null;
    }
    /**
     * Get all available sources
     */
    getSources() {
      return [...this.sources];
    }
  };
  var SourceMapResolver = class {
    constructor() {
      this.sourceMapCache = /* @__PURE__ */ new Map();
    }
    /**
     * Try to find source map for a given file URL
     */
    async findSourceMapForFile(fileUrl) {
      if (this.sourceMapCache.has(fileUrl)) {
        return this.sourceMapCache.get(fileUrl);
      }
      try {
        let sourceMapUrl = null;
        const response = await fetch(fileUrl);
        const content = await response.text();
        const inlineMatch = content.match(/\/\/# sourceMappingURL=data:application\/json[;,](?:charset[:=]\S+?[;,])?base64,(.*)/);
        if (inlineMatch) {
          const sourceMapData = JSON.parse(atob(inlineMatch[1]));
          const consumer = new BasicSourceMapConsumer(sourceMapData);
          this.sourceMapCache.set(fileUrl, consumer);
          return consumer;
        }
        const externalMatch = content.match(/\/\/# sourceMappingURL=(.*)/);
        if (externalMatch) {
          sourceMapUrl = new URL(externalMatch[1].trim(), fileUrl).href;
        } else {
          sourceMapUrl = fileUrl + ".map";
        }
        if (sourceMapUrl) {
          const mapResponse = await fetch(sourceMapUrl);
          if (mapResponse.ok) {
            const sourceMapData = await mapResponse.json();
            const consumer = new BasicSourceMapConsumer(sourceMapData);
            this.sourceMapCache.set(fileUrl, consumer);
            return consumer;
          }
        }
      } catch (error) {
        console.warn("Failed to load source map for", fileUrl, error);
      }
      return null;
    }
    /**
     * Resolve original position from generated position using source maps
     */
    async resolvePosition(fileUrl, line, column) {
      const sourceMap = await this.findSourceMapForFile(fileUrl);
      if (!sourceMap) return null;
      return sourceMap.originalPositionFor(line, column);
    }
    /**
     * Get enhanced location info by combining runtime data with source maps
     */
    async getEnhancedLocationInfo(fileUrl, line, column) {
      try {
        const originalPos = await this.resolvePosition(fileUrl, line, column);
        if (!originalPos) return null;
        const sourceMap = await this.findSourceMapForFile(fileUrl);
        if (!sourceMap) return null;
        const sourceContent = originalPos.source ? sourceMap.sourceContentFor(originalPos.source) : null;
        return {
          file: originalPos.source || fileUrl,
          line: originalPos.line,
          column: originalPos.column,
          originalSource: originalPos.source,
          sourcesContent: sourceContent ? [sourceContent] : void 0
        };
      } catch (error) {
        console.warn("Failed to get enhanced location info:", error);
        return null;
      }
    }
    /**
     * Clear the source map cache
     */
    clearCache() {
      this.sourceMapCache.clear();
    }
  };
  var sourceMapResolver = new SourceMapResolver();

  // src/inspector/detectors.ts
  function findNearestComponent(element, verbose = false) {
    if (!element || element === document.body) return null;
    const logger = createLogger(verbose);
    try {
      let componentInfo = getVueComponentInfo(element);
      if (componentInfo) {
        logger.log("\u{1F7E2} Vue component found:", componentInfo);
      } else {
        logger.log("\u{1F50D} No Vue component found for element:", element.tagName, "Checking properties:", {
          __vnode: !!element.__vnode,
          __vueParentComponent: !!element.__vueParentComponent,
          __vue__: !!element.__vue__,
          __v_inspector: !!element.__v_inspector
        });
      }
      if (!componentInfo) {
        componentInfo = getReactComponentInfo(element);
        if (componentInfo) {
          logger.log("\u{1F535} React component found:", componentInfo);
        }
      }
      if (!componentInfo) {
        componentInfo = getVanillaComponentInfo(element);
        if (componentInfo) {
          logger.log("\u{1F7E1} Vanilla component found:", componentInfo);
        }
      }
      if (componentInfo) {
        try {
          const selectorInfo = XPathUtils.generateRobustSelectors(element);
          componentInfo.selectors = selectorInfo;
          if (verbose) {
            logger.log("\u{1F3AF} Generated selectors:", {
              xpath: selectorInfo.primary.xpath,
              css: selectorInfo.primary.cssSelector,
              confidence: selectorInfo.confidence,
              fallbacks: selectorInfo.fallbacks.length
            });
          }
        } catch (error) {
          if (verbose) {
            logger.warn("Failed to generate selectors:", error);
          }
        }
        return componentInfo;
      }
      return findNearestComponent(element.parentElement, verbose);
    } catch (e8) {
      logger.error("Error finding nearest component:", e8);
      return null;
    }
  }
  function getReactComponentInfo(element) {
    if (!element) return null;
    const elementAny = element;
    const fiberKey = Object.keys(elementAny).find(
      (key) => key.startsWith("__reactFiber") || key.startsWith("__reactInternalInstance") || key.startsWith("_reactInternalFiber")
    );
    if (!fiberKey) {
      return null;
    }
    const fiber = elementAny[fiberKey];
    if (!fiber) {
      return null;
    }
    try {
      const componentInfo = extractReactComponentInfo(fiber, element);
      return componentInfo;
    } catch (error) {
      console.warn("Failed to extract React component info:", error);
      return null;
    }
  }
  function extractReactComponentInfo(fiber, element) {
    if (!fiber) return null;
    let currentFiber = fiber;
    let componentName = "";
    let componentFile = "";
    while (currentFiber) {
      if (currentFiber.type && typeof currentFiber.type === "function") {
        componentName = currentFiber.type.name || currentFiber.type.displayName || "Anonymous";
        if (currentFiber.type.__source) {
          componentFile = currentFiber.type.__source.fileName || "";
        }
        break;
      }
      if (currentFiber.type && currentFiber.type.prototype && currentFiber.type.prototype.render) {
        componentName = currentFiber.type.name || "Component";
        break;
      }
      currentFiber = currentFiber.return || currentFiber._debugOwner;
    }
    if (!componentName && !componentFile) {
      return null;
    }
    const componentInfo = {
      componentLocation: componentFile ? `${componentFile}@${componentName}` : componentName,
      componentName,
      framework: "react"
    };
    const elementLocationInfo = extractReactElementLocation(fiber, element);
    if (elementLocationInfo) {
      Object.assign(componentInfo, elementLocationInfo);
    }
    return componentInfo;
  }
  function extractReactElementLocation(fiber, element) {
    try {
      const locationInfo = {};
      if (fiber._debugSource) {
        locationInfo.elementLocation = {
          file: fiber._debugSource.fileName || "",
          line: fiber._debugSource.lineNumber || 0,
          column: fiber._debugSource.columnNumber || 0
        };
      }
      const hierarchy = buildReactSourceHierarchy(fiber, element);
      if (hierarchy) {
        locationInfo.sourceHierarchy = hierarchy;
      }
      const sourceMapInfo = extractReactSourceMap(fiber);
      if (sourceMapInfo) {
        locationInfo.sourceMap = sourceMapInfo;
      }
      return Object.keys(locationInfo).length > 0 ? locationInfo : null;
    } catch (error) {
      console.warn("Failed to extract React element location:", error);
      return null;
    }
  }
  function buildReactSourceHierarchy(fiber, element) {
    try {
      const parts = [];
      let currentFiber = fiber;
      while (currentFiber && parts.length < 3) {
        if (currentFiber.type && typeof currentFiber.type === "function") {
          const name = currentFiber.type.name || currentFiber.type.displayName;
          if (name && name !== "Fragment") {
            parts.unshift(name);
          }
        } else if (currentFiber.type && typeof currentFiber.type === "string") {
          parts.push(currentFiber.type);
        }
        currentFiber = currentFiber.return;
      }
      if (element.className && typeof element.className === "string") {
        const classes = element.className.split(" ").filter((c5) => c5 && !c5.includes("css-") && !c5.includes("emotion-")).slice(0, 2);
        if (classes.length > 0) {
          parts.push("." + classes.join("."));
        }
      }
      return parts.length > 0 ? parts.join(" > ") : null;
    } catch (error) {
      return null;
    }
  }
  function extractReactSourceMap(fiber) {
    try {
      if (fiber._debugSource) {
        return {
          originalLine: fiber._debugSource.lineNumber || 0,
          originalColumn: fiber._debugSource.columnNumber || 0,
          originalSource: fiber._debugSource.fileName || "",
          originalName: fiber.type?.name || fiber.type?.displayName
        };
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  function getVanillaComponentInfo(element) {
    const componentName = element.getAttribute("data-component-name");
    const componentFile = element.getAttribute("data-component-file");
    if (!componentName && !componentFile) {
      return null;
    }
    return {
      componentLocation: `${componentFile}@${componentName}`,
      framework: "vanilla"
    };
  }
  function getVueComponentInfo(element) {
    if (!element) return null;
    const elementAny = element;
    let codeLocation = elementAny.__vnode?.props?.__v_inspector;
    let vueInstance = null;
    let vnode = null;
    if (!codeLocation) {
      codeLocation = elementAny.__vueParentComponent?.vnode?.props?.__v_inspector;
      vueInstance = elementAny.__vueParentComponent;
      vnode = elementAny.__vueParentComponent?.vnode;
    }
    if (!codeLocation) {
      codeLocation = elementAny.__v_inspector;
    }
    if (!codeLocation) {
      vueInstance = elementAny.__vue__ || elementAny.__vueParentComponent;
      if (vueInstance) {
        codeLocation = vueInstance.__v_inspector || vueInstance.$options?.__v_inspector || vueInstance.type?.__v_inspector;
      }
    }
    if (!codeLocation && !vnode) {
      vnode = elementAny.__vnode || elementAny.$vnode;
      if (vnode) {
        codeLocation = vnode.__v_inspector || vnode.props?.__v_inspector || vnode.componentOptions?.__v_inspector;
      }
    }
    if (!codeLocation) {
      return null;
    }
    const componentInfo = {
      componentLocation: codeLocation,
      framework: "vue"
    };
    const elementLocationInfo = extractVueElementLocation(element, vnode, vueInstance);
    if (elementLocationInfo) {
      Object.assign(componentInfo, elementLocationInfo);
    }
    return componentInfo;
  }
  function extractVueElementLocation(element, vnode, _vueInstance) {
    try {
      const locationInfo = {};
      if (vnode?.loc) {
        locationInfo.elementLocation = {
          file: vnode.loc.source || "",
          line: vnode.loc.start?.line || 0,
          column: vnode.loc.start?.column || 0,
          endLine: vnode.loc.end?.line,
          endColumn: vnode.loc.end?.column,
          source: vnode.loc.source?.slice(vnode.loc.start?.offset, vnode.loc.end?.offset)
        };
      }
      if (vnode?.type?.name || element.tagName) {
        const hierarchy = buildVueSourceHierarchy(element, vnode);
        if (hierarchy) {
          locationInfo.sourceHierarchy = hierarchy;
        }
      }
      const sourceMapInfo = extractVueSourceMap(vnode, _vueInstance);
      if (sourceMapInfo) {
        locationInfo.sourceMap = sourceMapInfo;
      }
      return Object.keys(locationInfo).length > 0 ? locationInfo : null;
    } catch (error) {
      console.warn("Failed to extract Vue element location:", error);
      return null;
    }
  }
  function buildVueSourceHierarchy(element, vnode) {
    try {
      const parts = [];
      if (vnode?.type?.name) {
        parts.push(vnode.type.name);
      }
      if (element.tagName && element.tagName.toLowerCase() !== "div") {
        parts.push(element.tagName.toLowerCase());
      }
      if (element.className && typeof element.className === "string") {
        const classes = element.className.split(" ").filter((c5) => c5 && !c5.startsWith("v-") && !c5.includes("transition")).slice(0, 2);
        if (classes.length > 0) {
          parts.push("." + classes.join("."));
        }
      }
      return parts.length > 0 ? parts.join(" > ") : null;
    } catch (error) {
      return null;
    }
  }
  function extractVueSourceMap(vnode, _vueInstance) {
    try {
      if (vnode?.__source) {
        return {
          originalLine: vnode.__source.line || 0,
          originalColumn: vnode.__source.column || 0,
          originalSource: vnode.__source.file || "",
          originalName: vnode.__source.name
        };
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  // src/inspector/style.ts
  var TOOLBAR_STYLES = i`
  :host {
    /* CSS Custom Properties */
    --primary-font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --gradient-colors: linear-gradient(135deg, #FF6B6B, #FF9671, #FFA75F, #F9D423, #FECA57, #FF7E67, #FF8C42, #FFC857);
    --shadow-primary: rgba(255, 107, 107, 0.5);
    --border-radius: 6px;
    --transition-spring: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    --color-border: #e5e7eb;
    --color-text: #1f2937;
    --color-text-muted: #64748b;
    --color-bg-light: #f8fafc;
    --color-white: #ffffff;
    
    position: fixed;
    bottom: 5px;
    right: 5px;
    z-index: 999999;
    font-family: var(--primary-font) !important;
  }

  :host * {
    font-family: var(--primary-font) !important;
    box-sizing: border-box;
  }

  .hidden {
    display: none !important;
  }

  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    14% { background-position: 23% 77%; }
    27% { background-position: 52% 68%; }
    41% { background-position: 79% 42%; }
    56% { background-position: 95% 21%; }
    73% { background-position: 62% 30%; }
    88% { background-position: 31% 47%; }
    100% { background-position: 0% 50%; }
  }

  @keyframes blinkEye {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.1); }
  }

  @keyframes glowingAura {
    0% { box-shadow: 0 0 10px 5px rgba(255, 107, 107, 0.4), 0 0 20px 10px rgba(255, 150, 113, 0.2), 0 0 0 2px rgba(255, 255, 255, 0.1); }
    13% { box-shadow: 0 0 18px 12px rgba(249, 212, 35, 0.5), 0 0 28px 15px rgba(254, 202, 87, 0.3), 0 0 0 3px rgba(255, 255, 255, 0.16); }
    27% { box-shadow: 0 0 15px 8px rgba(255, 159, 243, 0.6), 0 0 24px 11px rgba(255, 140, 66, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.12); }
    42% { box-shadow: 0 0 22px 14px rgba(255, 200, 87, 0.55), 0 0 30px 16px rgba(255, 107, 107, 0.28), 0 0 0 4px rgba(255, 255, 255, 0.18); }
    58% { box-shadow: 0 0 12px 7px rgba(255, 166, 107, 0.45), 0 0 19px 9px rgba(255, 126, 103, 0.25), 0 0 0 2px rgba(255, 255, 255, 0.11); }
    73% { box-shadow: 0 0 20px 13px rgba(249, 212, 35, 0.62), 0 0 26px 14px rgba(255, 150, 113, 0.42), 0 0 0 3px rgba(255, 255, 255, 0.22); }
    87% { box-shadow: 0 0 16px 9px rgba(255, 107, 107, 0.53), 0 0 22px 13px rgba(254, 202, 87, 0.32), 0 0 0 2px rgba(255, 255, 255, 0.14); }
    100% { box-shadow: 0 0 10px 5px rgba(255, 107, 107, 0.4), 0 0 20px 10px rgba(255, 150, 113, 0.2), 0 0 0 2px rgba(255, 255, 255, 0.1); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }

  @keyframes dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .toolbar-button {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: var(--gradient-colors);
    background-size: 400% 400%;
    animation: gradientShift 7.3s ease-in-out infinite;
    border: none;
    color: var(--color-white);
    cursor: pointer;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.5s var(--transition-spring);
    position: relative;
    z-index: 10000000;
  }

  .toolbar-button::before {
    content: '';
    position: absolute;
    inset: -3px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 107, 107, 0.1) 0%, transparent 70%);
    filter: blur(4px);
    opacity: 0.3;
    z-index: -1;
    transition: all 0.3s ease;
  }


  .toolbar-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
  }

  .toolbar-button:hover::before {
    inset: -4px;
    filter: blur(6px);
    opacity: 0.4;
  }

  .toolbar-button.active {
    background-size: 400% 400%;
    animation: gradientShift 5.2s cubic-bezier(0.36, 0.11, 0.89, 0.32) infinite;
    transform: scale(1.08);
    filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.2));
  }

  .toolbar-button.active::before {
    inset: -5px;
    filter: blur(8px);
    opacity: 0.5;
  }

  .toolbar-button .icon {
    width: 18px;
    height: 18px;
    animation: blinkEye 5s infinite;
  }

  .toolbar-card {
    cursor: auto !important;
    position: absolute;
    bottom: 30px;
    right: 0px;
    background: white;
    border-radius: 5px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    padding: 12px;
    display: none;
    min-width: 380px;
    transform: translateY(20px);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    z-index: 1;
  }

  .toolbar-card.expanded {
    display: block;
    transform: translateY(0);
    opacity: 1;
  }

  .toolbar-header {
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
    width: 100%;
    gap: 8px;
  }

  .session-info {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--color-text-muted);
    padding: 4px 8px;
    background: var(--color-bg-light);
    border: 1px solid var(--color-border);
    border-radius: 4px;
  }

  .session-label {
    font-weight: 500;
  }

  .session-id {
    font-family: 'Monaco', 'Courier New', monospace;
    background: var(--color-white);
    padding: 2px 6px;
    border-radius: 3px;
    border: 1px solid var(--color-border);
    font-size: 10px;
    color: #374151;
    min-width: 60px;
    text-align: center;
  }


  .toolbar-actions {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
  }

  .toolbar-input {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    font-size: 13px;
    transition: border-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    width: 100%;
  }

  .toolbar-input:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
  }

  .action-button {
    padding: 4px 8px;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.4s var(--transition-spring);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    height: 26px;
    line-height: 1.3;
  }

  .inspect-button {
    background: #4b83da;
    border: 1px solid #2d5ca8;
    color: var(--color-white);
  }

  .inspect-button:hover {
    background: #3a72c9;
    box-shadow: 0 3px 6px rgba(59, 130, 246, 0.2);
  }

  .inspect-button:active { background: #2c5aa0; }

  .close-button {
    background: #e05252;
    border: 1px solid #b03e3e;
    color: var(--color-white);
    display: none;
  }

  .close-button:hover {
    background: #cc4545;
    box-shadow: 0 3px 6px rgba(224, 82, 82, 0.2);
  }

  .close-button:active { background: #b73a3a; }

  .new-chat-button {
    background: #4ead88;
    border: 1px solid #3a8a68;
    color: var(--color-white);
    height: 20px;
    font-size: 11px;
  }

  .new-chat-button:hover {
    background: #419a78;
    box-shadow: 0 3px 6px rgba(78, 173, 136, 0.2);
  }

  .new-chat-button:active { background: #358a6c; }

  .cancel-button {
    background: #f59e0b;
    border: 1px solid #d97706;
    color: var(--color-white);
  }

  .cancel-button:hover {
    background: #e5890c;
    box-shadow: 0 3px 6px rgba(245, 158, 11, 0.2);
  }

  .cancel-button:active { background: #d97706; }

  .clear-button {
    background: #6b7280;
    border: 1px solid #4b5563;
    color: var(--color-white);
  }

  .clear-button:hover {
    background: #5d646f;
    box-shadow: 0 3px 6px rgba(107, 114, 128, 0.2);
  }

  .clear-button:active { background: #4b5563; }

  .copy-button {
    background: #8b5cf6;
    border: 1px solid #7c3aed;
    color: var(--color-white);
  }

  .copy-button:hover {
    background: #7c3aed;
    box-shadow: 0 3px 6px rgba(139, 92, 246, 0.2);
  }

  .copy-button:active { background: #6d28d9; }

  .inspecting .close-button {
    display: inline-flex;
  }

  .inspecting .inspect-button {
    display: none;
  }

  .icon {
    width: 18px;
    height: 18px;
  }

  .json-display {
    margin-top: 12px;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    background: white;
    width: 380px;
    display: none;
    flex-direction: column;
  }

  .json-display.show {
    display: flex;
  }

  .json-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 10px;
    border-bottom: 1px solid #e5e7eb;
    background: #f8fafc;
    border-radius: 6px 6px 0 0;
  }

  .json-header span {
    font-size: 11px;
    font-weight: 500;
    color: #64748b;
  }

  .json-clear-button {
    padding: 2px 6px;
    border: none;
    border-radius: 3px;
    background: #e2e8f0;
    color: #64748b;
    font-size: 9px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .json-clear-button:hover {
    background: #cbd5e1;
  }

  .json-content {
    max-height: 400px;
    overflow: auto;
  }

  .message {
    padding: 0px;
    background: #fafbfc;
    border-left: 3px solid var(--color-border);
    font-family: var(--primary-font);
    color: var(--color-text);
    line-height: 1.4;
    font-size: 11px;
  }

  .message.assistant {
    border-left-color: #3b82f6;
    background: #f0f9ff;
  }

  .message.user {
    border-left-color: #10b981;
    background: #f0fdf4;
  }

  .message.system {
    border-left-color: #64748b;
    background: #f8fafc;
    font-size: 10px;
    color: #64748b;
  }

  .message.result {
    border-left-color: #8b5cf6;
    background: #faf5ff;
  }

  .message-wrapper {
    position: relative;
  }

  .badge {
    display: block;
    background: #4f46e5;
    color: white;
    font-size: 9px;
    font-weight: 600;
    padding: 2px 6px;
    vertical-align: top;
    border-top-right-radius: 4px;
  }

  /* Legacy message-based badge colors (fallback) */
  .message.assistant .badge {
    background: #3b82f6;
  }

  .message.user .badge {
    background: #10b981;
  }

  .message.system .badge {
    background: #64748b;
  }

  .message.result .badge {
    background: #8b5cf6;
  }

  /* New badge type-specific colors (higher specificity) */
  .badge.badge-system {
    background: #64748b;
  }

  .badge.badge-assistant {
    background: #3b82f6;
  }

  .badge.badge-todo {
    background: #10b981;
  }

  .badge.badge-tool-file {
    background: #f59e0b;
  }

  .badge.badge-tool-exec {
    background: #dc2626;
  }

  .badge.badge-tool-search {
    background: #8b5cf6;
  }

  .badge.badge-tool-web {
    background: #06b6d4;
  }

  .badge.badge-user {
    background: #10b981;
  }

  .badge.badge-complete {
    background: #059669;
  }

  .badge.badge-error {
    background: #dc2626;
  }

  .badge.badge-default {
    background: #6b7280;
  }

  .message-content{
    padding: 5px;
    white-space: break-spaces;
  }

  .message pre {
    margin: 4px 0;
    overflow-x: auto;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .meta {
    display: block;
    font-size: 9px;
    color: #94a3b8;
    padding: 5px;
    padding-top: 0px;
  }

  .tool-use {
    background: #f1f5f9;
    border: 1px solid #e2e8f0;
    border-radius: 3px;
    margin: 4px 0;
    padding: 4px 6px;
  }

  .tool-name {
    font-weight: 500;
    font-size: 10px;
    color: #475569;
  }

  .tool-input {
    font-family: 'Courier New', monospace;
    font-size: 9px;
    background: #ffffff;
    border: 1px solid #e2e8f0;
    border-radius: 2px;
    padding: 3px;
    margin-top: 2px;
    max-height: 60px;
    overflow-y: auto;
  }

  .message:last-child {
    margin-bottom: 0;
  }

  .message .tool-combined {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 6px 8px;
    margin: 4px 0;
    font-family: 'Courier New', monospace;
    font-size: 10px;
    line-height: 1.3;
  }

  .message .tool-section {
    margin: 3px 0;
    padding: 2px 0;
  }

  .message .tool-section:not(:last-child) {
    border-bottom: 1px solid #e5e7eb;
    padding-bottom: 4px;
  }

  .message[data-tool-call-id] {
    position: relative;
    transition: all 0.3s ease;
  }

  .message[data-tool-call-id] .badge {
    transition: all 0.3s ease;
  }

  @keyframes toolPulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }

  .toolbar-card.processing .toolbar-input,
  .toolbar-card.processing .toolbar-actions {
    display: none;
  }

  .toolbar-card.processing .new-chat-button {
    display: none !important;
  }

  .processing-indicator {
    display: none;
    text-align: center;
    padding: 20px;
    color: #6b7280;
    font-size: 14px;
    animation: pulse 2s infinite;
  }

  .toolbar-card.processing .processing-indicator {
    display: block;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }

  .processing-dots {
    display: inline-block;
    animation: dots 1.5s infinite;
  }

  .processing-message {
    margin-bottom: 3px;
    padding: 8px 12px;
    background: #fffbeb;
    border-left: 3px solid #f59e0b;
    font-family: var(--primary-font);
    font-size: 11px;
    color: #92400e;
    line-height: 1.4;
    display: none;
    align-items: center;
    gap: 8px;
  }

  .processing-message.show {
    display: flex;
  }

  .processing-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid #fbbf24;
    border-top: 2px solid #d97706;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .processing-text {
    font-weight: 500;
  }
`;

  // src/utils/html.ts
  var HtmlUtils = class {
    static escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
    static hashString(content) {
      let hash = 0;
      for (let i6 = 0; i6 < content.length; i6++) {
        const char = content.charCodeAt(i6);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash.toString();
    }
  };

  // src/inspector-toolbar.ts
  var CONFIG = {
    MAX_CONTENT_LENGTH: 1e4,
    MAX_RESULT_LENGTH: 1e4,
    MAX_INPUT_DISPLAY: 1e4,
    MESSAGE_HISTORY_LIMIT: 10
  };
  var _aiEndpoint, _cwd, _verbose, _isExpanded, _isInspecting, _isProcessing, _sessionId, _hasSelectedElements, _messages, _showInitiatingIndicator, _showProcessingMessage;
  var InspectorToolbar = class extends i4 {
    constructor() {
      super();
      __privateAdd(this, _aiEndpoint);
      __privateAdd(this, _cwd);
      __privateAdd(this, _verbose);
      __privateAdd(this, _isExpanded);
      __privateAdd(this, _isInspecting);
      __privateAdd(this, _isProcessing);
      __privateAdd(this, _sessionId);
      __privateAdd(this, _hasSelectedElements);
      __privateAdd(this, _messages);
      __privateAdd(this, _showInitiatingIndicator);
      __privateAdd(this, _showProcessingMessage);
      // Element refs
      this.promptInputRef = e7();
      this.jsonContentRef = e7();
      // Message formatter state
      this.todoWriteToolIds = /* @__PURE__ */ new Set();
      this.handleOutsideClick = (e8) => {
        if (!this.contains(e8.target) && this.isExpanded && !this.isInspecting) {
          this.collapseToolbar();
        }
      };
      this.aiEndpoint = "";
      this.cwd = "";
      this.verbose = false;
      this.isExpanded = false;
      this.isInspecting = false;
      this.isProcessing = false;
      this.sessionId = "";
      this.hasSelectedElements = false;
      this.messages = [];
      this.showInitiatingIndicator = false;
      this.showProcessingMessage = false;
      this.logger = createLogger(this.verbose);
      initializeConsoleErrorCapture();
      this.selectionManager = createElementSelectionManager();
      this.aiManager = createAIManager(this.verbose);
      this.inspectionManager = createInspectionManager(
        (element) => this.handleElementSelection(element),
        (element) => this.shouldIgnoreElement(element),
        (element) => this.selectionManager.hasElement(element)
      );
    }
    get aiEndpoint() {
      return __privateGet(this, _aiEndpoint);
    }
    set aiEndpoint(_2) {
      __privateSet(this, _aiEndpoint, _2);
    }
    get cwd() {
      return __privateGet(this, _cwd);
    }
    set cwd(_2) {
      __privateSet(this, _cwd, _2);
    }
    get verbose() {
      return __privateGet(this, _verbose);
    }
    set verbose(_2) {
      __privateSet(this, _verbose, _2);
    }
    get isExpanded() {
      return __privateGet(this, _isExpanded);
    }
    set isExpanded(_2) {
      __privateSet(this, _isExpanded, _2);
    }
    get isInspecting() {
      return __privateGet(this, _isInspecting);
    }
    set isInspecting(_2) {
      __privateSet(this, _isInspecting, _2);
    }
    get isProcessing() {
      return __privateGet(this, _isProcessing);
    }
    set isProcessing(_2) {
      __privateSet(this, _isProcessing, _2);
    }
    get sessionId() {
      return __privateGet(this, _sessionId);
    }
    set sessionId(_2) {
      __privateSet(this, _sessionId, _2);
    }
    get hasSelectedElements() {
      return __privateGet(this, _hasSelectedElements);
    }
    set hasSelectedElements(_2) {
      __privateSet(this, _hasSelectedElements, _2);
    }
    get messages() {
      return __privateGet(this, _messages);
    }
    set messages(_2) {
      __privateSet(this, _messages, _2);
    }
    get showInitiatingIndicator() {
      return __privateGet(this, _showInitiatingIndicator);
    }
    set showInitiatingIndicator(_2) {
      __privateSet(this, _showInitiatingIndicator, _2);
    }
    get showProcessingMessage() {
      return __privateGet(this, _showProcessingMessage);
    }
    set showProcessingMessage(_2) {
      __privateSet(this, _showProcessingMessage, _2);
    }
    // Helper methods to replace event emissions with direct property updates
    expandToolbar() {
      this.isExpanded = true;
    }
    collapseToolbar() {
      this.isExpanded = false;
    }
    enterInspectionModeInternal() {
      this.enterInspectionMode();
      this.isInspecting = true;
    }
    exitInspectionModeInternal() {
      this.exitInspectionMode();
      this.isInspecting = false;
    }
    startProcessing() {
      this.isProcessing = true;
      this.isInspecting = false;
    }
    endProcessing() {
      this.isProcessing = false;
    }
    updateSessionId(sessionId) {
      this.sessionId = sessionId || "";
    }
    addMessage(message) {
      if (message.type === "assistant") {
        this.trackTodoWriteToolIds(message);
      }
      if (this.isTodoWriteToolResult(message)) {
        return;
      }
      this.messages = [...this.messages, message];
      this.updateComplete.then(() => {
        if (this.jsonContentRef.value) {
          this.jsonContentRef.value.scrollTop = this.jsonContentRef.value.scrollHeight;
        }
      });
    }
    clearMessagesInternal() {
      this.messages = [];
      this.todoWriteToolIds.clear();
    }
    clearPrompt() {
      if (this.promptInputRef.value) {
        this.promptInputRef.value.value = "";
      }
    }
    clearSelection() {
      this.selectionManager.clearAllSelections();
      this.hasSelectedElements = false;
    }
    isTodoWriteToolResult(message) {
      if (message.type !== "user") return false;
      const userMessage = message.message;
      if (userMessage.content && Array.isArray(userMessage.content)) {
        return userMessage.content.some(
          (block) => block.type === "tool_result" && block.tool_use_id && this.isToolIdFromTodoWrite(block.tool_use_id)
        );
      }
      return false;
    }
    isToolIdFromTodoWrite(toolId) {
      return this.todoWriteToolIds.has(toolId);
    }
    trackTodoWriteToolIds(message) {
      const assistantMessage = message.message;
      if (assistantMessage.content && Array.isArray(assistantMessage.content)) {
        assistantMessage.content.forEach((block) => {
          if (block.type === "tool_use" && block.name === "TodoWrite" && block.id) {
            this.todoWriteToolIds.add(block.id);
          }
        });
      }
    }
    render() {
      return x`
      <button
        class=${e6({
        "toolbar-button": true,
        "active": this.isExpanded
      })}
        @click=${this.handleToggle}
      >
        <svg class="icon" fill="currentColor" viewBox="0 0 20 20">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
          <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
        </svg>
      </button>

      <div
        class=${e6({
        "toolbar-card": true,
        "expanded": this.isExpanded,
        "inspecting": this.isInspecting,
        "processing": this.isProcessing
      })}
      >
        <div class="toolbar-header">
          <div
            class=${e6({
        "session-info": true,
        "hidden": !this.sessionId
      })}
          >
            <span class="session-label">Session:</span>
            <span class="session-id">${this.sessionId.substring(0, 8)}</span>
            ${n5(this.isProcessing, () => x`
              <button class="action-button cancel-button" @click=${this.handleCancel}>
                <span>Cancel</span>
              </button>
            `)}
            <button class="action-button new-chat-button" @click=${this.handleNewChat}>
              <span>New Chat</span>
            </button>
          </div>
          <textarea
            ${n7(this.promptInputRef)}
            rows="2"
            autocomplete="off"
            class="toolbar-input"
            placeholder="Type your prompt then press Enter"
            @keydown=${this.handlePromptKeydown}
          ></textarea>
        </div>

        <div class="toolbar-actions">
          <button
            class="action-button inspect-button"
            @click=${this.handleInspect}
            ?disabled=${this.isProcessing}
          >
            <span>Inspect</span>
          </button>
          ${n5(this.hasSelectedElements, () => x`
            <button class="action-button clear-button" @click=${this.handleClearElements}>
              <span>Clear</span>
            </button>
          `)}
          ${n5(this.isInspecting, () => x`
            <button class="action-button close-button" @click=${this.handleCloseInspection}>
              <span>Cancel</span>
            </button>
          `)}
        </div>

        ${n5(this.showInitiatingIndicator, () => x`
          <div class="processing-indicator show">
            <div>Starting Claude Code<span class="processing-dots"></span></div>
          </div>
        `)}

        ${n5(this.messages.length > 0 || this.showProcessingMessage, () => x`
          <div class="json-display show">
            <div class="json-content" ${n7(this.jsonContentRef)}>
              ${this.messages.map((message) => this.renderMessage(message))}
            </div>
            ${n5(this.showProcessingMessage, () => x`
              <div class="processing-message show">
                <div class="processing-spinner"></div>
                <span class="processing-text">Processing request...</span>
              </div>
            `)}
          </div>
        `)}
      </div>
    `;
    }
    renderSystemMessage(message) {
      const content = `<strong>Model:</strong> ${message.model}<br><strong>Permission Mode:</strong> ${message.permissionMode}<br><strong>Working Directory:</strong> ${message.cwd}<br><strong>API Key Source:</strong> ${message.apiKeySource}<br>` + (message.tools?.length ? `<strong>Available Tools:</strong> ${message.tools.length} tools<br><small>${message.tools.slice(0, 5).join(", ")}${message.tools.length > 5 ? "..." : ""}</small><br>` : "") + (message.mcp_servers?.length ? `<strong>MCP Servers:</strong> ${message.mcp_servers.length}<br>${message.mcp_servers.map((server) => `<small>\u2022 ${server.name} (${server.status})</small>`).join("<br>")}<br>` : "") + (message.slash_commands?.length ? `<strong>Slash Commands:</strong> ${message.slash_commands.length}<br>` : "");
      return { content, badge: "System", meta: "" };
    }
    renderTodoListFromBlock(block) {
      return {
        kind: "html",
        value: this.renderTodos(block.input.todos)
      };
    }
    renderAssistantMessage(message) {
      const assistantMessage = message.message;
      const segments = [];
      let containsTodoList = false;
      let toolName = "";
      if (assistantMessage.content && Array.isArray(assistantMessage.content)) {
        assistantMessage.content.forEach((block) => {
          if (block.type === "text" && block.text) {
            segments.push({ kind: "text", value: block.text });
          } else if (block.type === "tool_use" && block.name) {
            if (block.name === "TodoWrite" && block.input && "todos" in block.input) {
              containsTodoList = true;
              segments.push(this.renderTodoListFromBlock(block));
            } else {
              toolName = block.name;
              const inputStr = block.input ? dump(block.input, { indent: 2 }) : "{}";
              segments.push({ kind: "text", value: inputStr });
            }
          } else if (block.text) {
            segments.push({ kind: "text", value: block.text });
          }
        });
      }
      if (segments.length === 0) {
        segments.push({ kind: "text", value: "No content available" });
      }
      const htmlParts = [];
      segments.forEach((seg) => {
        if (seg.kind === "html") {
          htmlParts.push(seg.value);
        } else {
          const text = seg.value || "";
          const display = text.length > CONFIG.MAX_CONTENT_LENGTH ? text.substring(0, CONFIG.MAX_CONTENT_LENGTH) + "..." : text;
          htmlParts.push(`<pre><code>${HtmlUtils.escapeHtml(display)}</code></pre>`);
        }
      });
      const content = htmlParts.join("");
      let metaInfo = "";
      if (assistantMessage.model) {
        metaInfo = `Model: ${assistantMessage.model}`;
      }
      if (assistantMessage.usage) {
        const usage = assistantMessage.usage;
        const tokens = [];
        if (usage.input_tokens) tokens.push(`${usage.input_tokens}\u2191`);
        if (usage.output_tokens) tokens.push(`${usage.output_tokens}\u2193`);
        if (usage.cache_read_input_tokens) tokens.push(`${usage.cache_read_input_tokens}(cached)`);
        if (tokens.length > 0) {
          const tokenInfo = `Tokens: ${tokens.join(" ")}`;
          metaInfo = metaInfo ? `${metaInfo} | ${tokenInfo}` : tokenInfo;
        }
      }
      ``;
      return { content, badge: containsTodoList ? "todo" : toolName.length > 0 ? toolName : "Claude", meta: metaInfo };
    }
    renderUserMessage(message) {
      const userMessage = message.message;
      let userContent = "User message";
      let toolId = "";
      if (userMessage.content && Array.isArray(userMessage.content)) {
        const toolResults = userMessage.content.filter((block) => block.type === "tool_result").map((block) => {
          const resultContent = block.content ? block.content : "No content";
          toolId += block.tool_use_id ? `${block.tool_use_id} ` : "";
          return resultContent;
        });
        if (toolResults.length > 0) {
          userContent = toolResults.join("\n");
        }
      }
      return { content: HtmlUtils.escapeHtml(userContent), badge: toolId ? toolId : "User", meta: "" };
    }
    renderResultMessage(message) {
      if (message.is_error) {
        const errorText = message.result || message.subtype || "Unknown error";
        const content = `<strong>Error:</strong> ${HtmlUtils.escapeHtml(errorText)}<br><strong>Duration:</strong> ${message.duration_ms}ms<br>` + (message.duration_api_ms ? `<strong>API Duration:</strong> ${message.duration_api_ms}ms<br>` : "") + (message.total_cost_usd ? `<strong>Cost:</strong> $${message.total_cost_usd.toFixed(4)}<br>` : "");
        return { content, badge: "Error", meta: "" };
      } else {
        let content = `<strong>Total Time:</strong> ${message.duration_ms}ms (API: ${message.duration_api_ms}ms)<br>`;
        if (message.total_cost_usd) {
          content += `<strong>Cost:</strong> $${message.total_cost_usd.toFixed(4)}<br>`;
        }
        if (message.usage) {
          const usage = message.usage;
          const tokens = [];
          if (usage.input_tokens) tokens.push(`${usage.input_tokens}\u2191`);
          if (usage.output_tokens) tokens.push(`${usage.output_tokens}\u2193`);
          if (usage.cache_read_input_tokens) tokens.push(`${usage.cache_read_input_tokens}(cached)`);
          if (tokens.length > 0) {
            content += `<strong>Tokens:</strong> ${tokens.join(" ")}<br>`;
          }
        }
        if (message.num_turns) {
          content += `<strong>Turns:</strong> ${message.num_turns}<br>`;
        }
        if (message.permission_denials?.length) {
          content += `<strong>Permission Denials:</strong> ${message.permission_denials.length}<br>`;
        }
        let metaInfo = "";
        if (message.usage) {
          const usage = message.usage;
          const tokens = [];
          if (usage.input_tokens) tokens.push(`${usage.input_tokens}\u2191`);
          if (usage.output_tokens) tokens.push(`${usage.output_tokens}\u2193`);
          if (usage.cache_read_input_tokens) tokens.push(`${usage.cache_read_input_tokens}(cached)`);
          if (tokens.length > 0) {
            metaInfo = `Tokens: ${tokens.join(" ")}`;
          }
        }
        return { content, badge: "Complete", meta: metaInfo };
      }
    }
    // Progress messages have been removed. Fallback rendering is handled by renderUnknownMessage.
    renderUnknownMessage(message) {
      const badge = `Unknown (${message.type})`;
      let fallbackContent;
      if ("message" in message && typeof message.message === "string") {
        fallbackContent = message.message;
      } else {
        fallbackContent = JSON.stringify(message, null, 2);
      }
      const displayContent = fallbackContent.length > CONFIG.MAX_CONTENT_LENGTH ? fallbackContent.substring(0, CONFIG.MAX_CONTENT_LENGTH) + "..." : fallbackContent;
      const isJsonContent = fallbackContent.startsWith("{") || fallbackContent.startsWith("[");
      const content = isJsonContent ? `<pre ><code>${HtmlUtils.escapeHtml(displayContent)}</code></pre>` : `${HtmlUtils.escapeHtml(displayContent)}`;
      return { content, badge, meta: "" };
    }
    renderMessage(message) {
      if (!this.shouldShowMessage(message)) {
        return E;
      }
      let content = "";
      let badge = "";
      let meta = "";
      try {
        const result = (() => {
          switch (message.type) {
            case "result":
              return this.renderResultMessage(message);
            case "assistant":
              return this.renderAssistantMessage(message);
            case "user":
              return this.renderUserMessage(message);
            case "system":
              return this.renderSystemMessage(message);
            default:
              return this.renderUnknownMessage(message);
          }
        })();
        content = result.content;
        badge = result.badge;
        meta = result.meta;
      } catch (error) {
        console.error("Error creating message:", error);
        badge = "Error";
        content = `<pre style="background:#fee;padding:6px;border-radius:4px;overflow-x:auto;font-size:8px"><code>${JSON.stringify(message)}</code></pre>`;
      }
      const formattedMessage = this.formatMessage(content, badge, meta);
      return x`
      <div class=${e6({
        "message": true,
        "assistant": message.type === "assistant",
        "user": message.type === "user",
        "system": message.type === "system",
        "result": message.type === "result"
      })} .innerHTML=${formattedMessage}></div>
    `;
    }
    // Event handlers
    handleToggle(e8) {
      e8.preventDefault();
      e8.stopPropagation();
      e8.stopImmediatePropagation();
      if (!this.isExpanded) {
        this.expandToolbar();
        if (this.selectionManager.getSelectedCount() === 0 && !this.isInspecting && !this.isProcessing) {
          this.enterInspectionModeInternal();
        }
      } else {
        if (this.isInspecting) {
          this.exitInspectionModeInternal();
        }
        this.collapseToolbar();
        this.clearSelection();
        this.clearPrompt();
      }
    }
    handleInspect() {
      if (!this.isProcessing) {
        this.enterInspectionModeInternal();
      }
    }
    handleClearElements() {
      this.clearSelection();
    }
    handleCloseInspection() {
      this.exitInspectionModeInternal();
    }
    async handleNewChat() {
      if (this.isProcessing) {
        this.logger.log("Cannot start new chat while processing");
        return;
      }
      if (this.promptInputRef.value) {
        this.promptInputRef.value.value = "";
      }
      this.selectionManager.clearAllSelections();
      this.hasSelectedElements = false;
      this.clearMessagesInternal();
      this.enterInspectionModeInternal();
      if (this.aiManager.isInitialized()) {
        try {
          await this.aiManager.newChat();
          this.updateSessionId(this.aiManager.getSessionId());
        } catch (error) {
          this.logger.error("Failed to start new chat:", error);
        }
      } else {
        this.logger.warn("AI manager not initialized");
      }
    }
    async handleCancel() {
      if (this.aiManager.isProcessing()) {
        this.aiManager.cancel();
        this.setProcessingState(false);
        console.log("success: Request cancelled");
        if (this.promptInputRef.value) {
          this.promptInputRef.value.value = "";
        }
        this.selectionManager.clearAllSelections();
        this.hasSelectedElements = false;
        this.clearMessagesInternal();
        if (this.aiManager.isInitialized()) {
          try {
            await this.aiManager.newChat();
            this.updateSessionId(this.aiManager.getSessionId());
          } catch (error) {
            this.logger.error("Failed to start new chat after cancel:", error);
          }
        }
      }
    }
    handlePromptKeydown(e8) {
      if (e8.key === "Enter" && !e8.shiftKey) {
        e8.preventDefault();
        const target = e8.target;
        this.handlePromptSubmit(target.value.trim());
      }
    }
    // Additional methods from original implementation
    enterInspectionMode() {
      this.updateComplete.then(() => {
        if (this.promptInputRef.value) {
          this.promptInputRef.value.focus();
        }
      });
      this.inspectionManager.enterInspectionMode();
    }
    exitInspectionMode() {
      this.inspectionManager.exitInspectionMode();
    }
    handleElementSelection(element) {
      if (this.selectionManager.hasElement(element)) {
        this.selectionManager.deselectElement(element);
      } else {
        this.selectionManager.selectElement(element, (el) => findNearestComponent(el, this.verbose));
      }
      this.hasSelectedElements = this.selectionManager.getSelectedCount() > 0;
    }
    shouldIgnoreElement(element) {
      if (element === this || this.contains(element)) return true;
      if (element.classList?.contains("inspector-badge")) return true;
      let currentElement = element;
      while (currentElement) {
        if (currentElement.classList?.contains("inspector-badge") || currentElement.classList?.contains("inspector-ignore")) {
          return true;
        }
        const parent = currentElement.parentNode;
        if (parent && parent.nodeType === Node.ELEMENT_NODE) {
          currentElement = parent;
        } else if ("host" in currentElement && currentElement.host instanceof Element) {
          currentElement = currentElement.host;
        } else {
          break;
        }
      }
      return false;
    }
    async handlePromptSubmit(prompt) {
      if (!prompt) {
        this.logger.log("Empty prompt, nothing to process");
        return;
      }
      if (this.isProcessing) {
        this.logger.log("Already processing, ignoring new prompt");
        return;
      }
      this.logger.log("AI Prompt submitted:", prompt);
      this.logger.log("Selected elements:", Array.from(this.selectionManager.getSelectedElements().keys()));
      if (this.isInspecting) {
        this.exitInspectionModeInternal();
      }
      const pageInfo = this.getCurrentPageInfo();
      let imagePaths;
      try {
        const selectedElementsArray = Array.from(this.selectionManager.getSelectedElements().keys());
        if (selectedElementsArray.length > 0 && this.aiEndpoint) {
          imagePaths = /* @__PURE__ */ new Map();
          const screenshotPromises = selectedElementsArray.map(async (element, index) => {
            try {
              const htmlElement = element;
              const dataUrl = await toPng(htmlElement, {
                quality: 0.8,
                pixelRatio: 1,
                style: {
                  transform: "scale(1)",
                  transformOrigin: "top left",
                  outline: "none"
                }
              });
              const tagName = element.tagName.toLowerCase();
              const fileName = `element__index-${index + 1}__tag-${tagName}.png`;
              const fullPath = `${this.cwd}/.instantcode/${fileName}`;
              const uploadResponse = await fetch(`${this.aiEndpoint}/upload-image`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  base64: dataUrl,
                  filePath: fullPath
                })
              });
              if (uploadResponse.ok) {
                const result = await uploadResponse.json();
                this.logger.log(`Screenshot of element ${index + 1} captured and uploaded:`, result.filePath);
                return { element, filePath: result.filePath };
              } else {
                this.logger.warn(`Failed to upload screenshot for element ${index + 1}`);
                return null;
              }
            } catch (elementError) {
              this.logger.warn(`Failed to capture screenshot for element ${index + 1}:`, elementError);
              return null;
            }
          });
          const uploadResults = await Promise.all(screenshotPromises);
          uploadResults.forEach((result) => {
            if (result && imagePaths) {
              imagePaths.set(result.element, result.filePath);
            }
          });
          this.logger.log("Screenshot capture completed", { totalElements: selectedElementsArray.length, successfulCaptures: imagePaths.size });
        }
      } catch (screenshotError) {
        this.logger.warn("Failed to capture screenshots:", screenshotError);
      }
      const selectedElementsHierarchy = this.selectionManager.buildHierarchicalStructure(
        (el) => findNearestComponent(el, this.verbose),
        imagePaths
      );
      if (this.aiEndpoint) {
        await this.callAI(prompt, selectedElementsHierarchy, pageInfo);
      } else {
        this.logger.warn("No AI endpoint provided. Set the ai-endpoint attribute to use AI features.");
      }
    }
    getCurrentPageInfo() {
      return {
        url: window.location.href,
        title: document.title
      };
    }
    async callAI(prompt, selectedElements, pageInfo) {
      if (!this.aiEndpoint) {
        this.logger.warn("No AI endpoint specified");
        return;
      }
      const originalPromptText = this.promptInputRef.value?.value || "";
      try {
        if (!this.aiManager.isInitialized()) {
          throw new Error("AI manager not initialized");
        }
        this.setProcessingState(true);
        const messageHandler = {
          onData: (data) => {
            console.log(JSON.stringify(data));
            if (data.session_id) {
              this.updateSessionId(data.session_id);
            }
            if (data.type === "system" && data.subtype === "init") {
              this.showInitiatingIndicator = false;
              this.showProcessingMessage = true;
            }
            if (data.type === "result") {
              if (this.promptInputRef.value) {
                this.promptInputRef.value.value = "";
              }
              this.showProcessingMessage = false;
              this.setProcessingState(false);
            }
            this.addMessage(data);
          },
          onError: (error) => {
            this.logger.error("AI subscription error:", error);
            console.log("error: Failed to send message");
            this.setProcessingState(false);
          },
          onComplete: () => {
            this.setProcessingState(false);
          }
        };
        await this.aiManager.sendMessage(
          prompt,
          selectedElements,
          pageInfo,
          this.cwd,
          messageHandler
        );
      } catch (error) {
        this.logger.error("Error calling AI endpoint:", error);
        if (this.promptInputRef.value) {
          this.promptInputRef.value.value = originalPromptText;
        }
        this.setProcessingState(false);
        this.logger.error("Error calling AI endpoint:", error.message || "Failed to connect to AI service");
      }
    }
    setProcessingState(isProcessing) {
      if (isProcessing) {
        this.startProcessing();
        this.showInitiatingIndicator = true;
        this.showProcessingMessage = true;
        window.onbeforeunload = () => "Processing in progress. Are you sure you want to leave?";
      } else {
        this.endProcessing();
        this.showInitiatingIndicator = false;
        this.showProcessingMessage = false;
        window.onbeforeunload = null;
      }
    }
    // Lifecycle methods
    connectedCallback() {
      super.connectedCallback();
      if (!this.aiManager.isInitialized()) {
        this.aiManager.initialize(this.aiEndpoint);
      }
      this.updateSessionId(this.aiManager.getSessionId());
      document.addEventListener("click", this.handleOutsideClick);
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      window.onbeforeunload = null;
      this.aiManager.destroy();
      this.inspectionManager.destroy();
      this.selectionManager.clearAllSelections();
      document.removeEventListener("click", this.handleOutsideClick);
    }
    shouldShowMessage(jsonData) {
      return true;
    }
    renderTodos(todos) {
      if (!Array.isArray(todos)) {
        return "<strong>TodoWrite</strong>\nInvalid todos format";
      }
      let html = "<div>";
      todos.forEach((todo) => {
        const statusIcon = this.getStatusIcon(todo.status);
        html += `<div style="margin: 4px 0; display: flex; align-items: flex-start; gap: 8px;">
        <span style="display: inline-flex; align-items: center; margin-top: 1px;">${statusIcon}</span>
        <span style="flex: 1; color: ${todo.status === "completed" ? "#666" : "inherit"}; ${todo.status === "completed" ? "text-decoration: line-through;" : ""}">${HtmlUtils.escapeHtml(todo.content)}</span>
      </div>`;
      });
      html += "</div>";
      return html;
    }
    getStatusIcon(status) {
      switch (status) {
        case "completed":
          return '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="7" fill="#28a745"/><path d="M11.5 5.5L6.5 10.5L4.5 8.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        case "in_progress":
          return '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.5C4.41 1.5 1.5 4.41 1.5 8C1.5 11.59 4.41 14.5 8 14.5C11.59 14.5 14.5 11.59 14.5 8" stroke="#007acc" stroke-width="1.5" stroke-linecap="round"/><path d="M8 4V8L10.5 10.5" stroke="#007acc" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        case "pending":
          return '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="6.5" stroke="#ffc107" stroke-width="1.5"/><path d="M8 5V8L10 10" stroke="#ffc107" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        default:
          return '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="6.5" stroke="#6c757d" stroke-width="1.5"/><path d="M8 5V9" stroke="#6c757d" stroke-width="1.5" stroke-linecap="round"/><circle cx="8" cy="11.5" r="0.75" fill="#6c757d"/></svg>';
      }
    }
    getStatusColor(status) {
      switch (status) {
        case "completed":
          return "#28a745";
        case "in_progress":
          return "#007acc";
        case "pending":
          return "#ffc107";
        default:
          return "#6c757d";
      }
    }
    getBadgeClass(badge) {
      const lowerBadge = badge.toLowerCase();
      if (lowerBadge === "system") return "badge-system";
      if (lowerBadge === "claude") return "badge-assistant";
      if (lowerBadge === "todo") return "badge-todo";
      if (lowerBadge.includes("read") || lowerBadge.includes("write") || lowerBadge.includes("edit")) return "badge-tool-file";
      if (lowerBadge.includes("bash") || lowerBadge.includes("exec")) return "badge-tool-exec";
      if (lowerBadge.includes("search") || lowerBadge.includes("grep") || lowerBadge.includes("glob")) return "badge-tool-search";
      if (lowerBadge.includes("web")) return "badge-tool-web";
      if (lowerBadge === "user") return "badge-user";
      if (lowerBadge === "complete") return "badge-complete";
      if (lowerBadge === "error") return "badge-error";
      return "badge-default";
    }
    formatMessage(content, badge, meta) {
      const badgeClass = this.getBadgeClass(badge || "");
      const badgeHtml = badge ? `<span class="badge ${badgeClass}">${badge}</span>` : "";
      const metaHtml = meta ? `<small class="meta">${meta}</small>` : "";
      return `${badgeHtml}<div class="message-content">${content}</div>${metaHtml}</div>`;
    }
  };
  _aiEndpoint = new WeakMap();
  _cwd = new WeakMap();
  _verbose = new WeakMap();
  _isExpanded = new WeakMap();
  _isInspecting = new WeakMap();
  _isProcessing = new WeakMap();
  _sessionId = new WeakMap();
  _hasSelectedElements = new WeakMap();
  _messages = new WeakMap();
  _showInitiatingIndicator = new WeakMap();
  _showProcessingMessage = new WeakMap();
  InspectorToolbar.styles = TOOLBAR_STYLES;
  __decorateClass([
    n4({ attribute: "ai-endpoint" })
  ], InspectorToolbar.prototype, "aiEndpoint", 1);
  __decorateClass([
    n4({ type: String })
  ], InspectorToolbar.prototype, "cwd", 1);
  __decorateClass([
    n4({ type: Boolean })
  ], InspectorToolbar.prototype, "verbose", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "isExpanded", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "isInspecting", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "isProcessing", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "sessionId", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "hasSelectedElements", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "messages", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "showInitiatingIndicator", 1);
  __decorateClass([
    r5()
  ], InspectorToolbar.prototype, "showProcessingMessage", 1);
  InspectorToolbar = __decorateClass([
    t3("inspector-toolbar")
  ], InspectorToolbar);
})();
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
lit-html/lit-html.js:
lit-element/lit-element.js:
@lit/reactive-element/decorators/custom-element.js:
@lit/reactive-element/decorators/property.js:
@lit/reactive-element/decorators/state.js:
@lit/reactive-element/decorators/event-options.js:
@lit/reactive-element/decorators/base.js:
@lit/reactive-element/decorators/query.js:
@lit/reactive-element/decorators/query-all.js:
@lit/reactive-element/decorators/query-async.js:
@lit/reactive-element/decorators/query-assigned-nodes.js:
lit-html/directive.js:
lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
lit-html/directives/when.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

@trpc/client/dist/httpBatchLink-CA96-gnJ.mjs:
  (* istanbul ignore if -- @preserve *)
*/
