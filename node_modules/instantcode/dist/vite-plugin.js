// src/vite-plugin.ts
import { spawn } from "node:child_process";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";
import { existsSync } from "node:fs";
var InspectorServerManager = class {
  constructor(options = {}) {
    this.serverProcess = null;
    const port = options.port ?? 7318;
    const listenAddress = options.listenAddress ?? "localhost";
    this.options = {
      port,
      listenAddress,
      publicAddress: options.publicAddress ?? `http://${listenAddress}:${port}`,
      verbose: options.verbose ?? false,
      mock: options.mock ?? false
    };
    const currentFileDir = dirname(fileURLToPath(import.meta.url));
    this.isDevelopment = currentFileDir.endsWith("/src") || currentFileDir.endsWith("\\src");
    if (this.isDevelopment) {
      this.packageDir = dirname(currentFileDir);
    } else {
      this.packageDir = dirname(currentFileDir);
    }
    this.log(`Package directory: ${this.packageDir}`);
    this.log(`Running in ${this.isDevelopment ? "development" : "production"} mode`);
  }
  async start() {
    if (this.serverProcess) {
      return;
    }
    let serverFile;
    let cmd;
    let args;
    if (this.isDevelopment) {
      serverFile = join(this.packageDir, "src", "index.ts");
      cmd = "bun";
      args = [serverFile];
    } else {
      serverFile = join(this.packageDir, "dist", "index.cjs");
      if (!existsSync(serverFile)) {
        const fallbackFile = join(this.packageDir, "src", "index.ts");
        if (existsSync(fallbackFile)) {
          this.log("dist/index.cjs not found, falling back to src/index.ts");
          serverFile = fallbackFile;
          cmd = "bun";
          args = [serverFile];
        } else {
          throw new Error(`Inspector server file not found at ${serverFile} or ${fallbackFile}`);
        }
      } else {
        cmd = "node";
        args = [serverFile];
      }
    }
    args.push("--port", String(this.options.port));
    args.push("--listen", this.options.listenAddress);
    if (this.options.publicAddress ?? `http://${this.options.listenAddress}:${this.options.port}`) {
      args.push("--public-address", this.options.publicAddress);
    }
    if (this.options.verbose) {
      args.push("--verbose");
    }
    if (this.options.mock) {
      args.push("--mock");
    }
    this.log(`Starting inspector server: ${cmd} ${args.join(" ")}`);
    this.log(`Working directory: ${this.packageDir}`);
    this.serverProcess = spawn(cmd, args, {
      cwd: this.packageDir,
      env: process.env,
      stdio: this.options.verbose ? "inherit" : "pipe"
    });
    if (!this.options.verbose && this.serverProcess.stdout) {
      this.serverProcess.stdout.on("data", (_data) => {
      });
    }
    if (!this.options.verbose && this.serverProcess.stderr) {
      this.serverProcess.stderr.on("data", (data) => {
        console.error(`[inspector-server] Error: ${data}`);
      });
    }
    this.serverProcess.on("error", (error) => {
      console.error("[inspector-server] Failed to start:", error);
    });
    this.serverProcess.on("exit", (code) => {
      if (code !== 0 && code !== null) {
        console.error(`[inspector-server] Process exited with code ${code}`);
      }
      this.serverProcess = null;
    });
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  async stop() {
    if (this.serverProcess) {
      this.log("Stopping inspector server...");
      this.serverProcess.kill("SIGTERM");
      await new Promise((resolve) => {
        if (!this.serverProcess) {
          resolve();
          return;
        }
        const timeout = setTimeout(() => {
          if (this.serverProcess) {
            this.log("Force killing inspector server...");
            this.serverProcess.kill("SIGKILL");
          }
          resolve();
        }, 5e3);
        this.serverProcess.on("exit", () => {
          clearTimeout(timeout);
          resolve();
        });
      });
      this.serverProcess = null;
    }
  }
  log(message) {
    if (this.options.verbose) {
      console.log(`[inspector-plugin] ${message}`);
    }
  }
  getInjectScript(cwd) {
    const params = new URLSearchParams({
      ...cwd && { cwd }
    });
    return `<script src="${this.options.publicAddress}/inspector-toolbar.js?${params}" type="module" async></script>`;
  }
  shouldInject() {
    return true;
  }
};
function inspectorPlugin(options = {}) {
  let serverManager;
  let projectRoot;
  return {
    name: "vite-plugin-inspector",
    // Only apply plugin during development (serve command)
    apply: "serve",
    configResolved(config) {
      projectRoot = config.root;
      serverManager = new InspectorServerManager(options);
    },
    async buildStart() {
      await serverManager.start();
    },
    transformIndexHtml(html) {
      if (!serverManager || !serverManager.shouldInject()) {
        return html;
      }
      const scriptTag = serverManager.getInjectScript(projectRoot);
      if (html.includes("</body>")) {
        return html.replace("</body>", `${scriptTag}
</body>`);
      } else if (html.includes("</html>")) {
        return html.replace("</html>", `${scriptTag}
</html>`);
      } else {
        return html + scriptTag;
      }
    },
    async closeBundle() {
      await serverManager.stop();
    },
    async buildEnd() {
      if (this.meta.watchMode === false) {
        await serverManager.stop();
      }
    }
  };
}
var vite_plugin_default = inspectorPlugin;
export {
  vite_plugin_default as default,
  inspectorPlugin
};
//# sourceMappingURL=vite-plugin.js.map
